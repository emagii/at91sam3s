<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAM3S Software Package: USB Device Enumeration</title>
<link href="common/style.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
    <div id="body">
        <div id="title">SAM3S Software Package 2.1</div>
        <div id="banner"></div>

<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="usb_library.html">USB Library</a>      </li>
      <li><a class="el" href="usbd_framework.html">AT91 USB device framework</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>USB Device Enumeration </h1>  </div>
</div>
<div class="contents">
<p>This page is a step-by-step guide on how to use the USB Device framework to produce a simple program that performs USB enumeration. In this example, everything is put into a single file. You can look at the main.c file provided with the framework to view the end result.</p>
<h2><a class="anchor" id="inc"></a>
Including the Necessary Headers</h2>
<p>Prior to using the framework, several header files have to be included. Please refer to <a class="el" href="usbd_framework_usage.html">USB Device Framework Usage</a> for more information.</p>
<h2><a class="anchor" id="global_var"></a>
Declaring Global Varibles</h2>
<p>Several object instances are necessary to use the various functions and methods of the USB framework. As following.</p>
<h3><a class="anchor" id="drv"></a>
USBD Driver</h3>
<p>The very first step is declare the USB driver which is then used by the Class driver. The <a class="el" href="struct_u_s_b_d_driver.html">USBDDriver</a> structure is used as a container for several variables, which must therefore be created first.</p>
<h4><a class="anchor" id="Endpoints"></a>
Endpoints</h4>
<p>Depending on the application, a particular number of endpoints have to be defined. For example, an MSD driver needs three endpoints whereas a CDC driver needs four. Refer to the corresponding specification for more information about the required number of endpoints. Since this example should only perform the USB enumeration, it will declare only one endpoint: Control endpoint 0.</p>
<p>Endpoints is configured by USBEndpointDescriptor in ref <a class="el" href="struct_u_s_b_d_driver_descriptors.html">USBDDriverDescriptors</a> for the driver. The FIFO banks is automatically set to its maximum value.</p>
<h4><a class="anchor" id="Callbacks"></a>
Callbacks</h4>
<p>To replace the default callback, you should remove the default callback file from makefile and add your own function definition.</p>
<table class="doxtable">
<tr>
<td><b> callback function file </b> </td><td><b> callback function </b> </td></tr>
<tr>
<td>USBDCallbacks_Initialized.o  </td><td><a class="el" href="usb_2usb__audio__headphone_2main_8c.html#a0ec0fee934fdef57f6e60cf46df2d8c3">USBDCallbacks_Initialized()</a>  </td></tr>
<tr>
<td>USBDCallbacks_Reset.o </td><td><a class="el" href="group__usbd__interface.html#ga9e41562d2721787dbca41dd5bd574fb3">USBDCallbacks_Reset()</a> </td></tr>
<tr>
<td>USBDCallbacks_Suspended.o </td><td><a class="el" href="group__usbd__interface.html#gaf30332628067d1dd8cd1a177f5dc66ac">USBDCallbacks_Suspended()</a> </td></tr>
<tr>
<td>USBDCallbacks_Resumed.o </td><td><a class="el" href="group__usbd__interface.html#gac077464ce6090a99a999031ee2b43abc">USBDCallbacks_Resumed()</a> </td></tr>
<tr>
<td>- <b>MUST</b> be defined </td><td><a class="el" href="usb_2usb__audio__headphone_2main_8c.html#ga9c59dbbbbf5065ba8da4fbf81d9f65d9">USBDCallbacks_RequestReceived()</a> </td></tr>
</table>
<h4><a class="anchor" id="Driver"></a>
Driver</h4>
<p>Depending on the chip used, there may or may not be a need to declare a low- level driver variable.</p>
<p>The default driver global variable is simply called usbdDriver, and will sufficient for this example. </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_u_s_b_d_driver.html">USBDDriver</a> <a class="code" href="usb_2usb__core_2main_8c.html#a3e181c734ec3f57f4bb7eaa3c6bf97dc">usbdDriver</a>;
</pre></div><h3><a class="anchor" id="Descriptors"></a>
Descriptors</h3>
<p>The USB specification 2.0 defines a set of descriptors used to give information about the device. Depending on the USB class implemented, different descriptors have to be used with varying values.</p>
<p>In this example program, only a few descriptors are required. The device descriptor is always mandatory, so it will have to be defined. At least one configuration descriptor is required, so one is implemented. The described configuration must have at least one interface, so one more descriptor is needed. Finally, no string descriptors are used:</p>
<h4><a class="anchor" id="Device"></a>
State Diagram</h4>
<p>The device descriptor used by this example looks like this: </p>
<div class="fragment"><pre class="fragment">  Device descriptor.
const USBDeviceDescriptor <a class="code" href="usb_2usb__core_2main_8c.html#abbdba57d1ad13dade8feba8e52f1aa5c">usbDeviceDescriptor</a> = {

    <span class="keyword">sizeof</span>(USBDeviceDescriptor),
    <a class="code" href="group__usb__desc__type.html#ga6363c61655b33b6312f0de0f317528e3">USBGenericDescriptor_DEVICE</a>,
    <a class="code" href="group__usb__release__number.html#ga69167f83b560d92391cf222d9d3690de">USBDeviceDescriptor_USB2_00</a>,
    0, <span class="comment">// No device class code</span>
    0, <span class="comment">// No device subclass code</span>
    0, <span class="comment">// No device protocol code</span>
    BOARD_USB_ENDPOINTS_MAXPACKETSIZE(0),
    0x03EB, <span class="comment">// Atmel vendor ID</span>
    0x0001, <span class="comment">// Product ID</span>
    0x0001, <span class="comment">// Product release 0.01</span>
    0, <span class="comment">// No manufacturer string descriptor</span>
    0, <span class="comment">// No product string descriptor</span>
    0, <span class="comment">// No serial number string descriptor</span>
    1 <span class="comment">// One possible configuration</span>
};
</pre></div><p> The values are nothing special here. Note that the first three fields have the same data in them (unless using USB 1.1). It is also very common to define the class, subclass and protocol values at the interface level.</p>
<ul>
<li>Note: The <em>vendor ID</em> value is provided by the USB-IF organization. The <em>product ID</em> is vendor-specific and can be assigned any value.</li>
</ul>
<h4><a class="anchor" id="Configuration"></a>
Descriptor</h4>
<p>When the configuration descriptor is requested by the host, via the GET_DESCRIPTOR command, the device must not only transmit this descriptor but also all the necessary interface and endpoint descriptors.</p>
<p>In order to do that easily, a structure must be defined for holding all the information. This way, the data to send is contiguous, making the request much simpler to fulfill. In the current example, the configuration descriptor must be followed by the first interface descriptor. The following structure is declared for that: </p>
<div class="fragment"><pre class="fragment"><span class="comment">// Configuration descriptors with one interface.</span>
<span class="keyword">struct </span><a class="code" href="struct_simple_configuration_descriptors.html">SimpleConfigurationDescriptors</a> {

    USBConfigurationDescriptor <a class="code" href="cciddriver_8c.html#a7634569d696db5c0fd83c1f138267913">configuration</a>;
    USBInterfaceDescriptor <a class="code" href="cciddriver_8c.html#a6f9e311890dd39caf727ade0d7109b50">interface</a>;
};
</pre></div><p> Now, the actual descriptors can be declared: </p>
<div class="fragment"><pre class="fragment"><span class="comment">// Configuration descriptors.</span>
<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="struct_simple_configuration_descriptors.html">SimpleConfigurationDescriptors</a> configurationDescriptors = {

    <span class="comment">// Configuration descriptor</span>
    {
        <span class="keyword">sizeof</span>(USBConfigurationDescriptor),
        <a class="code" href="group__usb__desc__type.html#ga3a0e7ca09c79c9b17866b19770d7dfe7">USBGenericDescriptor_CONFIGURATION</a>,
        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="struct_simple_configuration_descriptors.html">SimpleConfigurationDescriptors</a>),
        0, <span class="comment">// No interface in this configuration</span>
        1, <span class="comment">// This is configuration #1</span>
        0, <span class="comment">// No string descriptor for this configuration</span>
        BOARD_USB_BMATTRIBUTES,
        <a class="code" href="group__usb__attributes.html#gab63528cba8ea4c8178d79393caa5d5f1">USBConfigurationDescriptor_POWER</a>(100)
    },
    <span class="comment">// Interface descriptor</span>
    {
        <span class="keyword">sizeof</span>(USBInterfaceDescriptor),
        <a class="code" href="group__usb__desc__type.html#ga82c82ea74c0f8b487812ad73cc5ed4a4">USBGenericDescriptor_INTERFACE</a>,
        0, <span class="comment">// This is interface #0</span>
        0, <span class="comment">// This is setting #0 for interface</span>
        0, <span class="comment">// Interface has no endpoint</span>
        0, <span class="comment">// No interface class code</span>
        0, <span class="comment">// No interface subclass code</span>
        0, <span class="comment">// No interface protocol code</span>
        0, <span class="comment">// No string descriptor</span>
    }
};
</pre></div><p> Again, those are very generic values. For the interface descriptor, most of them are zeroed. This is because this example does not implement any functionality other than doing the USB enumeration.</p>
<h3><a class="anchor" id="class_drv"></a>
Class Driver</h3>
<p>The demonstration program is going to use the standard request handler discussed in <a class="el" href="usbd_std_req_handler.html">USBD Standard Request Handler</a> to perform the USB enumeration. To be able to do that, several structures must be declared.</p>
<h4><a class="anchor" id="Descriptors"></a>
Descriptors</h4>
<p>The <a class="el" href="struct_u_s_b_d_driver.html">USBDDriver</a> object needs a pointer to a list of descriptors. This is necessary to be able to answer the GET_DESCRIPTOR request. A <a class="el" href="struct_u_s_b_d_driver_descriptors.html">USBDDriverDescriptors</a> can be used to do that.</p>
<p>The actual descriptors list can be instantiated: </p>
<div class="fragment"><pre class="fragment"><span class="comment">// List of descriptors used by the device.</span>
<span class="keyword">const</span> <a class="code" href="struct_u_s_b_d_driver_descriptors.html">USBDDriverDescriptors</a> <a class="code" href="usb_2usb__core_2main_8c.html#a61db1f38a0e9cbd19395b557cb8e74a2">usbdDriverDescriptors</a> = {

    &amp;usbDeviceDescriptor,
    (<span class="keyword">const</span> USBConfigurationDescriptor *) &amp;configurationDescriptors,
#ifdef BOARD_USB_UDPHS
    0, <span class="comment">// No full-speed device qualifier descriptor</span>
    0, <span class="comment">// No full-speed other speed configuration descriptor</span>
    &amp;usbDeviceDescriptor,
    (<span class="keyword">const</span> USBConfigurationDescriptor *) &amp;configurationDescriptors,
    0, <span class="comment">// No high-speed device qualifier descriptor</span>
    0, <span class="comment">// No high-speed other speed configuration descriptor</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    0, <span class="comment">// No full-speed device qualifier descriptor</span>
    0, <span class="comment">// No full-speed other speed configuration descriptor</span>
    0, <span class="comment">// No high-speed device descriptor</span>
    0, <span class="comment">// No high-speed configuration descriptor</span>
    0, <span class="comment">// No high-speed device qualifier descriptor</span>
    0, <span class="comment">// No high-speed other speed configuration descriptor</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    0, <span class="comment">// No string descriptor</span>
    0  <span class="comment">// No string descriptor</span>
};
</pre></div><p> The core configuration descriptor, which is actually made up of the configuation descriptor and the first interface descriptor, has to be cast to the USBConfigurationDescriptor type.</p>
<h2><a class="anchor" id="Interrupt"></a>
Service Routines</h2>
<h3><a class="anchor" id="USB"></a>
Device Framework Architecture</h3>
<p>The USB controller peripheral generates an interrupt when an event occurs. Since that event must be forwarded to the USBD_IrqHandler method, an interrupt service routine must be installed to do that. </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> ISR_Usb()
 {
    <a class="code" href="group__usbd__hal.html#ga571a674fe9f9a1bba6ad08b3b0b28a80" title="Default SUPC interrupt handler for USBD.">USBD_IrqHandler</a>();
 }
</pre></div><p> Currently the default USBDCallbacks_Initialized will initialize the interrupt service routine automatically: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="usb_2usb__audio__headphone_2main_8c.html#a0ec0fee934fdef57f6e60cf46df2d8c3">USBDCallbacks_Initialized</a>()
{
    AIC_ConfigureIT(AT91C_ID_UDP, 0, <a class="code" href="group__usbd__hal.html#ga571a674fe9f9a1bba6ad08b3b0b28a80" title="Default SUPC interrupt handler for USBD.">USBD_IrqHandler</a>);
    AIC_EnableIT(AT91C_ID_UDP);
}
</pre></div><p> So the only thing you should do to initialize the interrupt service is to call <a class="el" href="group__usbd__interface.html#ga1fd3982402055e37aa879c199e0b7fee">USBD_Init()</a> in <a class="el" href="acc__irq_2main_8c.html#a840291bc02cba5474a4cb46a9b9566fe" title="acc_irq Application entry point.">main()</a>.</p>
<h3><a class="anchor" id="VBus"></a>
PIO Interrupt</h3>
<p>The Vbus power line can be monitored (if a PIO pin is connected to it) by the user application to enable or disable the USB controller peripheral when the device is connected/disconnected. To do that, an interrupt must be programmed when the status of Vbus changes. The ISR should call the <a class="el" href="group__usbd__interface.html#ga71b9264662d74666e4b058984e3346e5">USBD_Connect()</a> or <a class="el" href="group__usbd__interface.html#ga2d952f8cf9bde552cfd5559ae47e70fc">USBD_Disconnect()</a> function as follows: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> ISR_Vbus(<span class="keyword">const</span> <a class="code" href="struct_pin.html">Pin</a> *pPin)
{
    <span class="comment">// Check current level on VBus</span>
    <span class="keywordflow">if</span> (<a class="code" href="pio_8h.html#a1de94d9c6a29f9fa44e498e97edde1cc" title="Returns 1 if one or more PIO of the given Pin instance currently have a high level; otherwise returns...">PIO_Get</a>(&amp;pinVbus)) {
        <a class="code" href="group__usbd__interface.html#ga71b9264662d74666e4b058984e3346e5">USBD_Connect</a>();
    }
    <span class="keywordflow">else</span> {
        <a class="code" href="group__usbd__interface.html#ga2d952f8cf9bde552cfd5559ae47e70fc">USBD_Disconnect</a>();
    }
}
</pre></div><h2><a class="anchor" id="Callbacks"></a>
Callbacks</h2>
<p>A typical application based on this USB framework needs to instantiate most of the callbacks available. This section describes how to do that for a simple enumeration program.</p>
<h3><a class="anchor" id="Init"></a>
Init</h3>
<p>When an OS is not being used, the primary function that the <em>Init</em> callback must perform is interrupt handler installation. The previously defined ISR is thus configured and enabled: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="usb_2usb__audio__headphone_2main_8c.html#a0ec0fee934fdef57f6e60cf46df2d8c3">USBDCallbacks_Initialized</a>()
{
    <span class="comment">// Configure and enable the UDP interrupt</span>
    AIC_ConfigureIT(AT91C_ID_UDP, 0, <a class="code" href="group__usbd__hal.html#ga571a674fe9f9a1bba6ad08b3b0b28a80" title="Default SUPC interrupt handler for USBD.">USBD_IrqHandler</a>);
    AIC_EnableIT(AT91C_ID_UDP);
}
</pre></div><p> The default callback is defined in USBDCallbacks_Initialized.c.</p>
<h3><a class="anchor" id="susp_rsm"></a>
Suspend &amp; Resume</h3>
<p>The Suspend callback is used by the <a class="el" href="usbd_api.html">USBD API</a> to notify the device that it should enter low-power mode if required. The default callback is defined in USBDCallbacks_Suspended.c. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="group__usbd__interface.html#gaf30332628067d1dd8cd1a177f5dc66ac">USBDCallbacks_Suspended</a>(<span class="keywordtype">void</span>)
{
    <span class="comment">// Turn off LEDs</span>
    <a class="code" href="led_8h.html#a9aab99ae095ba16732f740a5655e855c">LED_Clear</a>(<a class="code" href="group__usbd__leds.html#gae4f40bc220a82472ac67a2bbd3dd484a">USBD_LEDPOWER</a>);
    <a class="code" href="led_8h.html#a9aab99ae095ba16732f740a5655e855c">LED_Clear</a>(<a class="code" href="group__usbd__leds.html#gab2c4294fe1a774d11741c6898b5f435d">USBD_LEDUSB</a>);
}
</pre></div><p> The Resume callback has to perform the reverse operation. The default callback is defined in USBDCallbacks_Resumed.c. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="group__usbd__interface.html#gac077464ce6090a99a999031ee2b43abc">USBDCallbacks_Resumed</a>(<span class="keywordtype">void</span>)
{
    <span class="comment">// Initialize LEDs</span>
    <a class="code" href="led_8h.html#a771437772006fafea906ca1613bb5593">LED_Configure</a>(<a class="code" href="group__usbd__leds.html#gae4f40bc220a82472ac67a2bbd3dd484a">USBD_LEDPOWER</a>);
    <a class="code" href="led_8h.html#a875871cf859444aecb6eebe7be2355ef">LED_Set</a>(<a class="code" href="group__usbd__leds.html#gae4f40bc220a82472ac67a2bbd3dd484a">USBD_LEDPOWER</a>);
    <a class="code" href="led_8h.html#a771437772006fafea906ca1613bb5593">LED_Configure</a>(<a class="code" href="group__usbd__leds.html#gab2c4294fe1a774d11741c6898b5f435d">USBD_LEDUSB</a>);
    <a class="code" href="led_8h.html#a9aab99ae095ba16732f740a5655e855c">LED_Clear</a>(<a class="code" href="group__usbd__leds.html#gab2c4294fe1a774d11741c6898b5f435d">USBD_LEDUSB</a>);
}
</pre></div><ul>
<li>Note: <em>It is not necessary to disable the USB controller logic (transceiver, clocks, peripheral) here. This is done directly by the USBD_IrqHandler function prior to triggering the callback. Typically, the callback must carry out the following operations:</em><ul>
<li>Disable the PLL</li>
<li>Switch to the slow 32 KHz clock</li>
<li>Turn off the clocks of used peripherals</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="NewRequest"></a>
NewRequest</h3>
<p>Since this example software should only perform the USB enumeration, the NewRequest callback can simply forward the call to the standard request handler method: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="usb_2usb__audio__headphone_2main_8c.html#ga9c59dbbbbf5065ba8da4fbf81d9f65d9">USBDCallbacks_RequestReceived</a>(<span class="keyword">const</span> <a class="code" href="struct_u_s_b_generic_request.html">USBGenericRequest</a> *request)
{
    <a class="code" href="group__usbd__interface.html#gaae0893893739fb365d088ea946cb2c89">USBDDriver_RequestHandler</a>(&amp;usbdDriver, request);
}
</pre></div><h2><a class="anchor" id="Main"></a>
Main</h2>
<p>The Main function of the program is used for PIO and driver (Class and USB) initialization, software connections of the device (by using USBD_Connect), and implementation of the product functionality.</p>
<p>In this case, the Main performs the first two steps. After that, since the enumeration is done through the event handler and the device does not do anything, it can simply enter an infinite loop:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="acc__irq_2main_8c.html#a840291bc02cba5474a4cb46a9b9566fe" title="acc_irq Application entry point.">main</a>()
{
    <span class="comment">// If they are present, configure Vbus &amp; Wake-up pins</span>
    <a class="code" href="pio__it_8h.html#ad31e05d6debb1e88af6124cd7751af22" title="Initializes the PIO interrupt management logic.">PIO_InitializeInterrupts</a>(0);

    <span class="comment">// USB initialization</span>
    <a class="code" href="group__usbd__interface.html#ga127547288f97f428de35e4d816d3c52d">USBDDriver_Initialize</a>(&amp;usbdDriver, &amp;usbdDriverDescriptors, 0);
    <a class="code" href="group__usbd__interface.html#ga1fd3982402055e37aa879c199e0b7fee">USBD_Init</a>();

    <span class="comment">// connect if needed</span>
    VBUS_CONFIGURE();
    <span class="keywordflow">while</span> (<a class="code" href="group__usbd__interface.html#ga804bf63efb2d4420a3bf42984e807e72">USBD_GetState</a>() &lt; <a class="code" href="group__usbd__states.html#ga4d1e58829e5878c4d2c23eac1f192358">USBD_STATE_CONFIGURED</a>);
    
    <span class="comment">// Main loop</span>
    <span class="keywordflow">while</span>(1)
    {
        <span class="comment">// Put USB class driver implementaion here</span>
    }
}
</pre></div> </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
