<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAM3S Software Package: S:/projets/EK/SAM3S-EK/sam3s_project_trunk/libraries/usb/device/device.dir Source File</title>
<link href="common/style.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
    <div id="body">
        <div id="title">SAM3S Software Package 2.1</div>
        <div id="banner"></div>

<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_bcc78437aa20a9e08ae4ab86f04766f4.html">libraries</a>      </li>
      <li><a class="el" href="dir_f1065d3d1896ef5ff2d50c3bcde1d4ab.html">usb</a>      </li>
      <li><a class="el" href="dir_72a696979eaed5d5ba2de246218d7e76.html">device</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>device.dir</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* ----------------------------------------------------------------------------</span>
<a name="l00002"></a>00002 <span class="comment"> *         ATMEL Microcontroller Software Support </span>
<a name="l00003"></a>00003 <span class="comment"> * ----------------------------------------------------------------------------</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (c) 2008, Atmel Corporation</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * All rights reserved.</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00009"></a>00009 <span class="comment"> * modification, are permitted provided that the following conditions are met:</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * - Redistributions of source code must retain the above copyright notice,</span>
<a name="l00012"></a>00012 <span class="comment"> * this list of conditions and the disclaimer below.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> * Atmel&#39;s name may not be used to endorse or promote products derived from</span>
<a name="l00015"></a>00015 <span class="comment"> * this software without specific prior written permission.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR</span>
<a name="l00018"></a>00018 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<a name="l00019"></a>00019 <span class="comment"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE</span>
<a name="l00020"></a>00020 <span class="comment"> * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<a name="l00021"></a>00021 <span class="comment"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<a name="l00022"></a>00022 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,</span>
<a name="l00023"></a>00023 <span class="comment"> * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<a name="l00024"></a>00024 <span class="comment"> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<a name="l00025"></a>00025 <span class="comment"> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,</span>
<a name="l00026"></a>00026 <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00027"></a>00027 <span class="comment"> * ----------------------------------------------------------------------------</span>
<a name="l00028"></a>00028 <span class="comment"> */</span>
<a name="l00029"></a>00029 <span class="comment"></span>
<a name="l00030"></a>00030 <span class="comment">/**</span>
<a name="l00031"></a>00031 <span class="comment"> *  \dir usb/device</span>
<a name="l00032"></a>00032 <span class="comment"> *</span>
<a name="l00033"></a>00033 <span class="comment"> *  \section Purpose</span>
<a name="l00034"></a>00034 <span class="comment"> * </span>
<a name="l00035"></a>00035 <span class="comment"> *  This directory provides definitions, structs and functions for USB device</span>
<a name="l00036"></a>00036 <span class="comment"> *  applications with Atmel AT91 microcontrollers and USB device framework.</span>
<a name="l00037"></a>00037 <span class="comment"> * </span>
<a name="l00038"></a>00038 <span class="comment"> *  You can develop your own USB device products based on the class-specific</span>
<a name="l00039"></a>00039 <span class="comment"> *  driver code provided, or just take them as a refference.</span>
<a name="l00040"></a>00040 <span class="comment"> * </span>
<a name="l00041"></a>00041 <span class="comment"> *  \section Contents</span>
<a name="l00042"></a>00042 <span class="comment"> *  There are two groups for the implement:</span>
<a name="l00043"></a>00043 <span class="comment"> *     -# The hardware interface driver for USB peripheral on AT91</span>
<a name="l00044"></a>00044 <span class="comment"> *        microcontrollers (UDP or UDPHS), this is a part of the</span>
<a name="l00045"></a>00045 <span class="comment"> *        \ref usbd_lib &quot;USBD Library&quot; (\ref usbd_framework).</span>
<a name="l00046"></a>00046 <span class="comment"> *        - &quot;core&quot;: hardware interface driver for AT91 USB peripheral</span>
<a name="l00047"></a>00047 <span class="comment"> *     -# The device class driver to class-specific device.</span>
<a name="l00048"></a>00048 <span class="comment"> *        - &quot;audio-speaker&quot;</span>
<a name="l00049"></a>00049 <span class="comment"> *        - &quot;ccid&quot;</span>
<a name="l00050"></a>00050 <span class="comment"> *        - &quot;cdc-serial&quot;</span>
<a name="l00051"></a>00051 <span class="comment"> *        - &quot;hid-keyboard&quot;</span>
<a name="l00052"></a>00052 <span class="comment"> *        - &quot;massstorage&quot;</span>
<a name="l00053"></a>00053 <span class="comment"> *        - &quot;composite&quot;</span>
<a name="l00054"></a>00054 <span class="comment"> * </span>
<a name="l00055"></a>00055 <span class="comment"> *  For more information about what a particular group contains, please refer to</span>
<a name="l00056"></a>00056 <span class="comment"> *  its documentation page.</span>
<a name="l00057"></a>00057 <span class="comment"> * </span>
<a name="l00058"></a>00058 <span class="comment"> */</span>
<a name="l00059"></a>00059 <span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment">/**</span>
<a name="l00061"></a>00061 <span class="comment"> \page usbd_api USBD API</span>
<a name="l00062"></a>00062 <span class="comment"></span>
<a name="l00063"></a>00063 <span class="comment"> See also \subpage usbd_api_struct &quot;USBD API Structures&quot; and</span>
<a name="l00064"></a>00064 <span class="comment"> \subpage usbd_api_method &quot;USBD API Methods&quot;.</span>
<a name="l00065"></a>00065 <span class="comment"> </span>
<a name="l00066"></a>00066 <span class="comment"> \section usbd_api_struct_sec USBD API Structs</span>
<a name="l00067"></a>00067 <span class="comment"></span>
<a name="l00068"></a>00068 <span class="comment"> Several specific structures are used by the USBD API to perform various</span>
<a name="l00069"></a>00069 <span class="comment"> operations, such as invoking callbacks or accessing the USBD controller.</span>
<a name="l00070"></a>00070 <span class="comment"> </span>
<a name="l00071"></a>00071 <span class="comment"> There are two main structures:</span>
<a name="l00072"></a>00072 <span class="comment"> - \ref USBDDriver :</span>
<a name="l00073"></a>00073 <span class="comment"> It is the main structure of the USB API. It should be instanciated</span>
<a name="l00074"></a>00074 <span class="comment"> in class-specific USB device driver or user application.</span>
<a name="l00075"></a>00075 <span class="comment"> - \ref USBDDriverDescriptors :</span>
<a name="l00076"></a>00076 <span class="comment"> It is a list of all descriptors used by a USB device driver. It</span>
<a name="l00077"></a>00077 <span class="comment"> should be instanciated in class-specific USB device driver or</span>
<a name="l00078"></a>00078 <span class="comment"> user application and passed to USBD by USBDDriver_Initialize.</span>
<a name="l00079"></a>00079 <span class="comment"></span>
<a name="l00080"></a>00080 <span class="comment"> \section usbd_api_method_sec USBD API Methods</span>
<a name="l00081"></a>00081 <span class="comment"> </span>
<a name="l00082"></a>00082 <span class="comment"> The USB API provides serveral methods to perform the following operations:</span>
<a name="l00083"></a>00083 <span class="comment"> - Changing the device state</span>
<a name="l00084"></a>00084 <span class="comment">    - \ref USBD_Init</span>
<a name="l00085"></a>00085 <span class="comment">    - \ref USBD_Connect, \ref USBD_Disconnect</span>
<a name="l00086"></a>00086 <span class="comment">    - \ref USBD_SetAddress</span>
<a name="l00087"></a>00087 <span class="comment">    - \ref USBD_SetConfiguration</span>
<a name="l00088"></a>00088 <span class="comment">    - \ref USBD_GetState</span>
<a name="l00089"></a>00089 <span class="comment">    - \ref usbd_state_diagram &quot;USB Device State Diagram&quot;</span>
<a name="l00090"></a>00090 <span class="comment"> - Handling events coming from the USB controller</span>
<a name="l00091"></a>00091 <span class="comment">    - \ref USBD_IrqHandler</span>
<a name="l00092"></a>00092 <span class="comment"> - Modifying the behavior of an endpoint</span>
<a name="l00093"></a>00093 <span class="comment">    - \ref USBD_ConfigureEndpoint</span>
<a name="l00094"></a>00094 <span class="comment">    - \ref USBD_Stall</span>
<a name="l00095"></a>00095 <span class="comment">    - \ref USBD_Halt</span>
<a name="l00096"></a>00096 <span class="comment">    - \ref USBD_Unhalt</span>
<a name="l00097"></a>00097 <span class="comment">    - \ref USBD_IsHalted</span>
<a name="l00098"></a>00098 <span class="comment"> - Transferring data</span>
<a name="l00099"></a>00099 <span class="comment">    - \ref USBD_Write</span>
<a name="l00100"></a>00100 <span class="comment">    - \ref USBD_Read</span>
<a name="l00101"></a>00101 <span class="comment">    - USBD_IsoWrite</span>
<a name="l00102"></a>00102 <span class="comment"> - Special functions</span>
<a name="l00103"></a>00103 <span class="comment">    - \ref USBD_RemoteWakeUp</span>
<a name="l00104"></a>00104 <span class="comment"></span>
<a name="l00105"></a>00105 <span class="comment"> See \ref usbd_api_method &quot;USBD API Methods&quot; for detailed informations.</span>
<a name="l00106"></a>00106 <span class="comment"></span>
<a name="l00107"></a>00107 <span class="comment">*/</span>
<a name="l00108"></a>00108 <span class="comment"></span>
<a name="l00109"></a>00109 <span class="comment">/**</span>
<a name="l00110"></a>00110 <span class="comment"> \page usbd_api_struct USBD API Structures</span>
<a name="l00111"></a>00111 <span class="comment"></span>
<a name="l00112"></a>00112 <span class="comment"> \section struct USBD API Structures</span>
<a name="l00113"></a>00113 <span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment"> Several specific structures are used by the USBD API to perform various</span>
<a name="l00115"></a>00115 <span class="comment"> operations, such as invoking callbacks or accessing the USBD controller.</span>
<a name="l00116"></a>00116 <span class="comment"> </span>
<a name="l00117"></a>00117 <span class="comment"> There are two main structures:</span>
<a name="l00118"></a>00118 <span class="comment"> - USBDDriver:</span>
<a name="l00119"></a>00119 <span class="comment"> It is the main structure of the USB API. It should be instanciated</span>
<a name="l00120"></a>00120 <span class="comment"> in class-specific USB device driver or user application.</span>
<a name="l00121"></a>00121 <span class="comment"> - USBDDriverDescriptors:</span>
<a name="l00122"></a>00122 <span class="comment"> It is a list of all descriptors used by a USB device driver. It</span>
<a name="l00123"></a>00123 <span class="comment"> should be instanciated in class-specific USB device driver or</span>
<a name="l00124"></a>00124 <span class="comment"> user application and passed to USBD by USBDDriver_Initialize.</span>
<a name="l00125"></a>00125 <span class="comment"></span>
<a name="l00126"></a>00126 <span class="comment"> */</span>
<a name="l00127"></a>00127 <span class="comment"></span>
<a name="l00128"></a>00128 <span class="comment">/**</span>
<a name="l00129"></a>00129 <span class="comment"> \page usbd_api_method USBD API Methods</span>
<a name="l00130"></a>00130 <span class="comment"></span>
<a name="l00131"></a>00131 <span class="comment"> \section api_fun USBD API methods</span>
<a name="l00132"></a>00132 <span class="comment"> </span>
<a name="l00133"></a>00133 <span class="comment"> The USB API provides serveral methods to perform the following operations:</span>
<a name="l00134"></a>00134 <span class="comment"> - Changing the device state</span>
<a name="l00135"></a>00135 <span class="comment">    - \ref USBD_Init</span>
<a name="l00136"></a>00136 <span class="comment">    - \ref usbd_conn_api &quot;USBD_Connect, USBD_Disconnect&quot;</span>
<a name="l00137"></a>00137 <span class="comment">    - \ref USBD_SetAddress</span>
<a name="l00138"></a>00138 <span class="comment">    - \ref USBD_SetConfiguration</span>
<a name="l00139"></a>00139 <span class="comment">    - \ref USBD_GetState</span>
<a name="l00140"></a>00140 <span class="comment">    - \ref usbd_state_diagram &quot;USB Device State Diagram&quot;</span>
<a name="l00141"></a>00141 <span class="comment"> - Handling events coming from the USB controller</span>
<a name="l00142"></a>00142 <span class="comment">    - \ref USBD_IrqHandler</span>
<a name="l00143"></a>00143 <span class="comment"> - Modifying the behavior of an endpoint</span>
<a name="l00144"></a>00144 <span class="comment">    - \ref USBD_ConfigureEndpoint</span>
<a name="l00145"></a>00145 <span class="comment">    - \ref USBD_Stall</span>
<a name="l00146"></a>00146 <span class="comment">    - \ref usbd_halt_api &quot;USBD_Halt, USBD_Unhalt, USBD_IsHalted&quot;</span>
<a name="l00147"></a>00147 <span class="comment"> - Transferring data</span>
<a name="l00148"></a>00148 <span class="comment">    - \ref USBD_Write</span>
<a name="l00149"></a>00149 <span class="comment">    - \ref USBD_Read</span>
<a name="l00150"></a>00150 <span class="comment">    - USBD_IsoWrite</span>
<a name="l00151"></a>00151 <span class="comment"> - Special functions</span>
<a name="l00152"></a>00152 <span class="comment">    - \ref USBD_RemoteWakeUp</span>
<a name="l00153"></a>00153 <span class="comment"></span>
<a name="l00154"></a>00154 <span class="comment"> \section ctrl_state Controlling the Device State</span>
<a name="l00155"></a>00155 <span class="comment"></span>
<a name="l00156"></a>00156 <span class="comment"> Chapter 9 of the USB specification 2.0 describes the various states a device</span>
<a name="l00157"></a>00157 <span class="comment"> can be in. Most of the methods of this API are used to change between those</span>
<a name="l00158"></a>00158 <span class="comment"> states.</span>
<a name="l00159"></a>00159 <span class="comment"></span>
<a name="l00160"></a>00160 <span class="comment"> \subsection USBD_Init</span>
<a name="l00161"></a>00161 <span class="comment"></span>
<a name="l00162"></a>00162 <span class="comment"> \ref USBD_Init is the first method to call in a user application. Technically,</span>
<a name="l00163"></a>00163 <span class="comment"> it must occur just before entering the Attached state. It performs the</span>
<a name="l00164"></a>00164 <span class="comment"> following actions:</span>
<a name="l00165"></a>00165 <span class="comment">    - USB Device driver and endpoint state initialization</span>
<a name="l00166"></a>00166 <span class="comment">    - D+ pull-up configuration and disabling</span>
<a name="l00167"></a>00167 <span class="comment">    - UDP hardware initialization (Peripheral and clock init)</span>
<a name="l00168"></a>00168 <span class="comment"></span>
<a name="l00169"></a>00169 <span class="comment"> A USB device uses a pull-up on the D+ line to signal its connection to the</span>
<a name="l00170"></a>00170 <span class="comment"> host. Depending on the USB controller present on the chip, either an</span>
<a name="l00171"></a>00171 <span class="comment"> internal or external pull-up is used. In both cases, its configuration is</span>
<a name="l00172"></a>00172 <span class="comment"> performed directly by this method. Please refer to the documentation of a</span>
<a name="l00173"></a>00173 <span class="comment"> particular controller for more information about the D+ pull-up.</span>
<a name="l00174"></a>00174 <span class="comment"></span>
<a name="l00175"></a>00175 <span class="comment"> The ini callback has to perform several mandatory operations at this point.</span>
<a name="l00176"></a>00176 <span class="comment"> You can find the default operations in USBDCallbacks_Initialized.</span>
<a name="l00177"></a>00177 <span class="comment"></span>
<a name="l00178"></a>00178 <span class="comment"> \subsection usbd_conn_api USBD_Connect, USBD_Disconnect</span>
<a name="l00179"></a>00179 <span class="comment"></span>
<a name="l00180"></a>00180 <span class="comment"> These two methods control the state of the D+ upll-up. This makes it possible</span>
<a name="l00181"></a>00181 <span class="comment"> to connect of disconnect the device by software when needed. \ref USBD_Connect</span>
<a name="l00182"></a>00182 <span class="comment"> changes the device state from Powered to Default, while \ref USBD_Disconnect</span>
<a name="l00183"></a>00183 <span class="comment"> changes from either Default, Address or Configured to Powered.</span>
<a name="l00184"></a>00184 <span class="comment"></span>
<a name="l00185"></a>00185 <span class="comment"> \subsection USBD_SetAddress</span>
<a name="l00186"></a>00186 <span class="comment"></span>
<a name="l00187"></a>00187 <span class="comment"> \ref USBD_SetAddress extracts the information from the last received</span>
<a name="l00188"></a>00188 <span class="comment"> SETUP packet to either change the device state from Default to</span>
<a name="l00189"></a>00189 <span class="comment"> Address or from Address to Default. The difference is made</span>
<a name="l00190"></a>00190 <span class="comment"> depending on the value of the wValue field of the request.</span>
<a name="l00191"></a>00191 <span class="comment"> </span>
<a name="l00192"></a>00192 <span class="comment"> This method must only be called right after the SET_ADDRESS</span>
<a name="l00193"></a>00193 <span class="comment"> request is received.</span>
<a name="l00194"></a>00194 <span class="comment"> </span>
<a name="l00195"></a>00195 <span class="comment"> \subsection USBD_SetConfiguration</span>
<a name="l00196"></a>00196 <span class="comment"></span>
<a name="l00197"></a>00197 <span class="comment"> This function operates in a way similar to \ref USBD_SetAddress. When the</span>
<a name="l00198"></a>00198 <span class="comment"> SETUP packet containing a SET_CONFIGURATION request is received,</span>
<a name="l00199"></a>00199 <span class="comment"> \ref USBD_SetConfiguration should be called to extract the new configuration</span>
<a name="l00200"></a>00200 <span class="comment"> value to adopt. If the wValue field of the request is non-zero, then the</span>
<a name="l00201"></a>00201 <span class="comment"> device must adopt the new configuration and enter the Configuration state;</span>
<a name="l00202"></a>00202 <span class="comment"> otherwise, it returns (or stays) in the Address state.</span>
<a name="l00203"></a>00203 <span class="comment"></span>
<a name="l00204"></a>00204 <span class="comment"> \subsection USBD_GetState</span>
<a name="l00205"></a>00205 <span class="comment"></span>
<a name="l00206"></a>00206 <span class="comment"> As its name implies, USBD_GetState simply returns the current state of the USB</span>
<a name="l00207"></a>00207 <span class="comment"> driver. See state definitions on \ref usbd_states &quot;USB device states&quot;.</span>
<a name="l00208"></a>00208 <span class="comment"> - \ref USBD_STATE_SUSPENDED</span>
<a name="l00209"></a>00209 <span class="comment"> - \ref USBD_STATE_ATTACHED</span>
<a name="l00210"></a>00210 <span class="comment"> - \ref USBD_STATE_POWERED</span>
<a name="l00211"></a>00211 <span class="comment"> - \ref USBD_STATE_DEFAULT</span>
<a name="l00212"></a>00212 <span class="comment"> - \ref USBD_STATE_ADDRESS</span>
<a name="l00213"></a>00213 <span class="comment"> - \ref USBD_STATE_CONFIGURED</span>
<a name="l00214"></a>00214 <span class="comment"></span>
<a name="l00215"></a>00215 <span class="comment"> \subsection Device State Diagram</span>
<a name="l00216"></a>00216 <span class="comment"> See \subpage usbd_state_diagram &quot;USB Device State Diagram&quot;</span>
<a name="l00217"></a>00217 <span class="comment"></span>
<a name="l00218"></a>00218 <span class="comment"> \section event_hdl Event Handling (\ref USBD_IrqHandler)</span>
<a name="l00219"></a>00219 <span class="comment"> Several events can occur at the USB controller level:</span>
<a name="l00220"></a>00220 <span class="comment"> - End of bus reset</span>
<a name="l00221"></a>00221 <span class="comment"> - Reception of a SETUP packet</span>
<a name="l00222"></a>00222 <span class="comment"> - Change of bus activity (active -&gt; idle -&gt; active ..)</span>
<a name="l00223"></a>00223 <span class="comment"> - Completin of an endpoint operation</span>
<a name="l00224"></a>00224 <span class="comment"> - ...</span>
<a name="l00225"></a>00225 <span class="comment"></span>
<a name="l00226"></a>00226 <span class="comment"> Whenever such an event occurs, it must be forwarded to the USBD API to be</span>
<a name="l00227"></a>00227 <span class="comment"> handled in an appropriate way. The USBD_IrqHandler performs this</span>
<a name="l00228"></a>00228 <span class="comment"> functionality, so the controller interrupt must be configured to call it.</span>
<a name="l00229"></a>00229 <span class="comment"></span>
<a name="l00230"></a>00230 <span class="comment"> Several &lt;b&gt;callbacks&lt;/b&gt; can be triggered depending on the event notified by</span>
<a name="l00231"></a>00231 <span class="comment"> the controller:</span>
<a name="l00232"></a>00232 <span class="comment"> - Suspend, when the bus is idle</span>
<a name="l00233"></a>00233 <span class="comment"> - Resume, when the bus becomes active again</span>
<a name="l00234"></a>00234 <span class="comment"> - NewRequest, when a setup packet is received on a control endpoint</span>
<a name="l00235"></a>00235 <span class="comment"> - StartOfFrame, every 1 ms (for full-speed controllers) or 125us (for high-</span>
<a name="l00236"></a>00236 <span class="comment">   speed controllers)</span>
<a name="l00237"></a>00237 <span class="comment"></span>
<a name="l00238"></a>00238 <span class="comment"> More information about these callbacks and their expected behavior can be</span>
<a name="l00239"></a>00239 <span class="comment"> found in \ref usbd_callback_api &quot;USBD Callback API&quot;.</span>
<a name="l00240"></a>00240 <span class="comment"></span>
<a name="l00241"></a>00241 <span class="comment"> \section ep_fun Endpoint Behavior Modification</span>
<a name="l00242"></a>00242 <span class="comment"></span>
<a name="l00243"></a>00243 <span class="comment"> The USBD API offers following functions to control how an endpoint operates.</span>
<a name="l00244"></a>00244 <span class="comment"> - \ref USBD_ConfigureEndpoint</span>
<a name="l00245"></a>00245 <span class="comment"> - \ref USBD_Stall</span>
<a name="l00246"></a>00246 <span class="comment"> - \ref USBD_Halt</span>
<a name="l00247"></a>00247 <span class="comment"> - \ref USBD_Unhalt</span>
<a name="l00248"></a>00248 <span class="comment"> - \ref USBD_IsHalted</span>
<a name="l00249"></a>00249 <span class="comment"></span>
<a name="l00250"></a>00250 <span class="comment"> \subsection USBD_ConfigureEndpoint</span>
<a name="l00251"></a>00251 <span class="comment"> \ref USBD_ConfigureEndpoint is used to configure an endpoint at the USB</span>
<a name="l00252"></a>00252 <span class="comment"> controller level. An appropriate endpoint descriptor must be provided to</span>
<a name="l00253"></a>00253 <span class="comment"> do that. The descriptor is used to configure the endpoint type (either</span>
<a name="l00254"></a>00254 <span class="comment"> Control, Bulk, Interrupt or Isochronous), direction (IN or OUT) and address.</span>
<a name="l00255"></a>00255 <span class="comment"></span>
<a name="l00256"></a>00256 <span class="comment"> Control endpoint 0 is automatically configured by the USBD API when the End of</span>
<a name="l00257"></a>00257 <span class="comment"> bus reset event is signalled by the USB controller. Therefore, there is no need</span>
<a name="l00258"></a>00258 <span class="comment"> to do it manually.</span>
<a name="l00259"></a>00259 <span class="comment"></span>
<a name="l00260"></a>00260 <span class="comment"> \subsection USBD_Stall</span>
<a name="l00261"></a>00261 <span class="comment"> The \ref USBD_Stall method causes and endpoint to acknowledge its next received</span>
<a name="l00262"></a>00262 <span class="comment"> packet with a STALL handshake. Further packets are then handled normally.</span>
<a name="l00263"></a>00263 <span class="comment"></span>
<a name="l00264"></a>00264 <span class="comment"> Most of the time, this method should be used with endpoint 0 to signal the</span>
<a name="l00265"></a>00265 <span class="comment"> host that the device cannot process a command.</span>
<a name="l00266"></a>00266 <span class="comment"></span>
<a name="l00267"></a>00267 <span class="comment"> \subsection usbd_halt_api USBD_Halt, USBD_Unhalt, USBD_IsHalted</span>
<a name="l00268"></a>00268 <span class="comment"> \ref USBD_Halt sets the Halt status of an endpoint. When in Halt mode, every</span>
<a name="l00269"></a>00269 <span class="comment"> received packet is acknowledged with a STALL handshake instead of being</span>
<a name="l00270"></a>00270 <span class="comment"> handled normally.</span>
<a name="l00271"></a>00271 <span class="comment"></span>
<a name="l00272"></a>00272 <span class="comment"> &lt;i&gt;USB_Halt&lt;/i&gt; can be called either with the USB_SET_FEATURE, USB_CLEAR_FEATURE</span>
<a name="l00273"></a>00273 <span class="comment"> or USB_GET_STATUS parameter to modify the endpoint Halt state.</span>
<a name="l00274"></a>00274 <span class="comment"></span>
<a name="l00275"></a>00275 <span class="comment"> \ref USBD_Unhalt clears the Halt status of an endpoint.</span>
<a name="l00276"></a>00276 <span class="comment"></span>
<a name="l00277"></a>00277 <span class="comment"> \ref USBD_IsHalted gets the Halt status of an endpoint.</span>
<a name="l00278"></a>00278 <span class="comment"></span>
<a name="l00279"></a>00279 <span class="comment"> \section data_tran Data Transfer</span>
<a name="l00280"></a>00280 <span class="comment"> Data transfer (IN or OUT) on an endpoint can be performed by calling two</span>
<a name="l00281"></a>00281 <span class="comment"> methods, USBD_Write and USBD_Read.</span>
<a name="l00282"></a>00282 <span class="comment"></span>
<a name="l00283"></a>00283 <span class="comment"> \subsection USBD_Write</span>
<a name="l00284"></a>00284 <span class="comment"> The USBD_Write function sends a data payload on a specific endpoint. If the</span>
<a name="l00285"></a>00285 <span class="comment"> data payload equals or exceeds the maximum packet size of the endpoint, then</span>
<a name="l00286"></a>00286 <span class="comment"> several IN transactions are necessary. This method should only be called on an</span>
<a name="l00287"></a>00287 <span class="comment"> IN or Control endpoint.</span>
<a name="l00288"></a>00288 <span class="comment"></span>
<a name="l00289"></a>00289 <span class="comment"> The write is performed &lt;b&gt;asynchronously&lt;/b&gt;, i.e., the function returns</span>
<a name="l00290"></a>00290 <span class="comment"> immediately without waiting for the transfer to finish. When the transfer is</span>
<a name="l00291"></a>00291 <span class="comment"> complete, an optional user-provided callback function is called. This makes it</span>
<a name="l00292"></a>00292 <span class="comment"> possible to create an &lt;b&gt;OS-friendly synchronous function&lt;/b&gt; by locking and</span>
<a name="l00293"></a>00293 <span class="comment"> unlocking a semaphore before and after each write.</span>
<a name="l00294"></a>00294 <span class="comment"></span>
<a name="l00295"></a>00295 <span class="comment"> This function handles double-buffering, if it is supported by the USB</span>
<a name="l00296"></a>00296 <span class="comment"> controller and if it has been enabled for the endpoint. Do not forget that</span>
<a name="l00297"></a>00297 <span class="comment"> using double-buffering is mandatory for isochronous transactions.</span>
<a name="l00298"></a>00298 <span class="comment"></span>
<a name="l00299"></a>00299 <span class="comment"> - &lt;b&gt;Note&lt;/b&gt;</span>
<a name="l00300"></a>00300 <span class="comment">       The double-buffering this function supported is only in period of each</span>
<a name="l00301"></a>00301 <span class="comment">       write action. That is, when the function is invoked to start transfer</span>
<a name="l00302"></a>00302 <span class="comment">       trunk of data, the data is automatically splitted to several IN</span>
<a name="l00303"></a>00303 <span class="comment">       transactions and ping-pong is started on the 2nd transaction. But when</span>
<a name="l00304"></a>00304 <span class="comment">       all the data of the trunk is finished the ping-pong is stopped. So it can</span>
<a name="l00305"></a>00305 <span class="comment">       not process the list of buffer that should use double-buffering all the</span>
<a name="l00306"></a>00306 <span class="comment">       time. See USBD_IsoWrite for such kind of operations.</span>
<a name="l00307"></a>00307 <span class="comment"></span>
<a name="l00308"></a>00308 <span class="comment"> \subsection USBD_Read</span>
<a name="l00309"></a>00309 <span class="comment"> The \ref USBD_Read reads incoming data on an endpoint. The transfer stops either</span>
<a name="l00310"></a>00310 <span class="comment"> when the provided buffer is full, or a short packet (size inferior to the</span>
<a name="l00311"></a>00311 <span class="comment"> endpoint maximum packet size) is received. This method must only be called on</span>
<a name="l00312"></a>00312 <span class="comment"> an OUT or Control endpoint.</span>
<a name="l00313"></a>00313 <span class="comment"></span>
<a name="l00314"></a>00314 <span class="comment"> The read is performed &lt;b&gt;asynchronously&lt;/b&gt;, i.e., the function returns</span>
<a name="l00315"></a>00315 <span class="comment"> immediately without waiting for the transfer to finish. When the transfer is</span>
<a name="l00316"></a>00316 <span class="comment"> complete, an optional user-provided callback function is called. This makes it</span>
<a name="l00317"></a>00317 <span class="comment"> possible to create an &lt;b&gt;OS-friendly synchronous function&lt;/b&gt; by locking and</span>
<a name="l00318"></a>00318 <span class="comment"> unlocking a semaphore before and after each read.</span>
<a name="l00319"></a>00319 <span class="comment"></span>
<a name="l00320"></a>00320 <span class="comment"> This function handles &lt;b&gt;double-buffering&lt;/b&gt;, if it is supported by the USB</span>
<a name="l00321"></a>00321 <span class="comment"> controller and if it has been enabled for the endpoint. Do not forget that</span>
<a name="l00322"></a>00322 <span class="comment"> using double-buffering is mandatory for isochronous transactions.</span>
<a name="l00323"></a>00323 <span class="comment"></span>
<a name="l00324"></a>00324 <span class="comment"> \subsection USBD_IsoWrite</span>
<a name="l00325"></a>00325 <span class="comment"> The \ref USBD_IsoWrite function sends a buffer list on a specific endpoint. The</span>
<a name="l00326"></a>00326 <span class="comment"> each buffer&#39;s payload should be equals or less than the maximum packet size of</span>
<a name="l00327"></a>00327 <span class="comment"> the endpoint. The transfer ends when all buffera are sent out. And the buffer</span>
<a name="l00328"></a>00328 <span class="comment"> is previously sent can be filled with new data before the transfer ends. To</span>
<a name="l00329"></a>00329 <span class="comment"> maitain a ring buffer for the outgoing stream. This method should only be</span>
<a name="l00330"></a>00330 <span class="comment"> called on an ISO IN endpoint.</span>
<a name="l00331"></a>00331 <span class="comment"></span>
<a name="l00332"></a>00332 <span class="comment"> The write is performed &lt;b&gt;asynchronously&lt;/b&gt;, i.e., the function returns immediately</span>
<a name="l00333"></a>00333 <span class="comment"> without waiting for the transfer to finish. When the transfer is complete, an</span>
<a name="l00334"></a>00334 <span class="comment"> optional user-provided callback function is called. This makes it possible to</span>
<a name="l00335"></a>00335 <span class="comment"> create an &lt;b&gt;OS-friendly synchronous function&lt;/b&gt; by locking and unlocking a</span>
<a name="l00336"></a>00336 <span class="comment"> semaphore before and after each write.</span>
<a name="l00337"></a>00337 <span class="comment"></span>
<a name="l00338"></a>00338 <span class="comment"> This function handles double-buffering, if it is supported by the USB</span>
<a name="l00339"></a>00339 <span class="comment"> controller and if it has been enabled for the endpoint. Do not forget that</span>
<a name="l00340"></a>00340 <span class="comment"> using double-buffering is mandatory for isochronous transactions.</span>
<a name="l00341"></a>00341 <span class="comment"></span>
<a name="l00342"></a>00342 <span class="comment"> \section special_fun Special Functions</span>
<a name="l00343"></a>00343 <span class="comment"></span>
<a name="l00344"></a>00344 <span class="comment"> - USBD_RemoteWakeUp() : This method starts a remote wakeup procedure. This makes</span>
<a name="l00345"></a>00345 <span class="comment"> it possible for a suspended device to wake a host with may itself be</span>
<a name="l00346"></a>00346 <span class="comment"> suspended.</span>
<a name="l00347"></a>00347 <span class="comment"></span>
<a name="l00348"></a>00348 <span class="comment">*/</span>
<a name="l00349"></a>00349 <span class="comment"></span>
<a name="l00350"></a>00350 <span class="comment">/**</span>
<a name="l00351"></a>00351 <span class="comment"> \page usbd_state_diagram USB Device State Diagram</span>
<a name="l00352"></a>00352 <span class="comment"></span>
<a name="l00353"></a>00353 <span class="comment"> \image html USBDeviceStateDiagram.png &quot;Changing the Device State&quot;</span>
<a name="l00354"></a>00354 <span class="comment"></span>
<a name="l00355"></a>00355 <span class="comment">*/</span>
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 <span class="comment">/* (Image Link Backup)</span>
<a name="l00358"></a>00358 <span class="comment">&lt;img src=&quot;USBDeviceStateDiagram.png&quot; border=0 alt=&quot;USBDeviceStateDiagram.png&quot; usemap=&quot;#USBD_ST_DIA&quot;&gt;</span>
<a name="l00359"></a>00359 <span class="comment">&lt;MAP NAME=&quot;USBD_ST_DIA&quot;&gt;</span>
<a name="l00360"></a>00360 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;172,0,330,0,330,26,172,26,172,0&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBD_Init53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBD_Init&amp;nbsp;&amp;nbsp;(void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Initializes the specified USB driver            This&lt;BR&gt;function initializes the current FIFO bank of&lt;BR&gt;endpoints,            configures the pull-up and VBus&lt;BR&gt;lines, disconnects the pull-up and            then&lt;BR&gt;trigger the Init callback.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00361"></a>00361 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;269,390,425,390,425,416,269,416,269,390&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBD_SetAddress2593655934&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBD_SetAddress&amp;nbsp;&amp;nbsp;(unsigned char address)&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Sets the device address.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00362"></a>00362 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;76,390,233,390,233,416,76,416,76,390&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBD_SetAddress2593655934&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBD_SetAddress&amp;nbsp;&amp;nbsp;(0)&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Unsets the device address.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00363"></a>00363 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;76,509,233,509,233,535,76,535,76,509&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBD_SetConfiguration2593655934&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBD_SetConfiguration&amp;nbsp;&amp;nbsp;(0)&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Changes the device state from Configured to Address.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00364"></a>00364 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;261,509,418,509,418,535,261,535,261,509&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBD_SetConfiguration2593655934&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBD_SetConfiguration&amp;nbsp;&amp;nbsp;(unsigned char cfgnum)&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Changes the device state from Address to Configured.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00365"></a>00365 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;284,242,440,242,440,269,284,269,284,242&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBD_Connect53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBD_Connect&amp;nbsp;&amp;nbsp;(void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Enables the pull-up on the D+ line to connect the device to the USB.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00366"></a>00366 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;60,242,217,242,217,269,60,269,60,242&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBD_Disconnect53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBD_Disconnect&amp;nbsp;&amp;nbsp;(void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Disables the pull-up on the D+ line to disconnect the&lt;BR&gt;device from the bus.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00367"></a>00367 <span class="comment">&lt;/MAP&gt;</span>
<a name="l00368"></a>00368 <span class="comment"></span>
<a name="l00369"></a>00369 <span class="comment">&lt;MAP NAME=&quot;usbd_cb_invo_fc&quot;&gt;</span>
<a name="l00370"></a>00370 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;436,739,600,739,600,765,436,765,436,739&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBDCallbacks_Resumed53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBDCallbacks_Resumed&amp;nbsp;&amp;nbsp;(void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Invoked when the USB device leaves the Suspended state.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00371"></a>00371 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;436,406,600,406,600,432,436,432,436,406&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBDCallbacks_Resumed53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBDCallbacks_Resumed&amp;nbsp;&amp;nbsp;(void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Invoked when the USB device leaves the Suspended state.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00372"></a>00372 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;436,605,600,605,600,632,436,632,436,605&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBDCallbacks_Suspended53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBDCallbacks_Suspended&amp;nbsp;&amp;nbsp;(void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Invoked when the USB device gets suspended. By default,&lt;BR&gt;turns off all LEDs.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00373"></a>00373 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;436,339,600,339,600,365,436,365,436,339&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;coreUSBDCallbacks_Suspended53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBDCallbacks_Suspended&amp;nbsp;&amp;nbsp;(void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Invoked when the USB device gets suspended. By default,&lt;BR&gt;turns off all LEDs.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00374"></a>00374 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;436,272,600,272,600,299,436,299,436,272&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBDCallbacks_RequestReceived2520836348&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBDCallbacks_RequestReceived&amp;nbsp;&amp;nbsp;(const USBGenericRequest * request)&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Triggered when the USB host emits a new SETUP request.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00375"></a>00375 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;436,206,600,206,600,232,436,232,436,206&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBDCallbacks_Reset53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBDCallbacks_Reset&amp;nbsp;&amp;nbsp;( void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Triggered when the USB host emits a RESET.&#39;)&quot;&gt;</span>
<a name="l00376"></a>00376 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;436,102,600,102,600,129,436,129,436,102&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBDCallbacks_Initialized53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBDCallbacks_Initialized&amp;nbsp;&amp;nbsp;(void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Invoked after the USB driver has been initialized.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00377"></a>00377 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;221,374,384,374,384,400,221,400,221,374&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBD_IrqHandler53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBD_IrqHandler&amp;nbsp;&amp;nbsp;(void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;UDP interrupt handler. Manages device status changes.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00378"></a>00378 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;221,307,384,307,384,333,221,333,221,307&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBD_IrqHandler53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBD_IrqHandler&amp;nbsp;&amp;nbsp;(void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;UDP interrupt handler. Manages device status changes.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00379"></a>00379 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;221,240,384,240,384,266,221,266,221,240&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBD_IrqHandler53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBD_IrqHandler&amp;nbsp;&amp;nbsp;(void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;UDP interrupt handler. Manages device status changes.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00380"></a>00380 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;221,173,384,173,384,199,221,199,221,173&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBD_IrqHandler53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBD_IrqHandler&amp;nbsp;&amp;nbsp;(void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;UDP interrupt handler. Manages device status changes.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00381"></a>00381 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;221,36,384,36,384,62,221,62,221,36&quot; onmouseover=&quot;link(&#39;_member&#39;,&#39;core/USBD_Init53616&#39;,this);overLibDiagram();return overlib(&#39;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;BR&gt;void&amp;nbsp;&amp;nbsp;USBD_Init&amp;nbsp;&amp;nbsp;(void )&#39;,CAPTION,&#39;&lt;strong&gt;Brief description&lt;/strong&gt;&lt;BR&gt;Initializes the USB driver.&#39;);&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00382"></a>00382 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;0,407,163,407,163,434,0,434,0,407&quot; onmouseover=&quot;overLibDiagram();return overlib(&#39;UDP_ISR: AT91C_UDP_SOFINT&#39;)&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00383"></a>00383 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;0,340,163,340,163,367,0,367,0,340&quot; onmouseover=&quot;overLibDiagram();return overlib(&#39;UDP_ISR: AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM&#39;)&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00384"></a>00384 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;0,273,163,273,163,300,0,300,0,273&quot; onmouseover=&quot;overLibDiagram();return overlib(&#39;UDP_ISR: AT91C_UDP_RXSUSP&#39;)&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00385"></a>00385 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;0,139,163,139,163,165,0,165,0,139&quot; onmouseover=&quot;overLibDiagram();return overlib(&#39;UDP_ISR: AT91C_UDP_ENDBUSRES&#39;)&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00386"></a>00386 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;0,206,163,206,163,232,0,232,0,206&quot; onmouseover=&quot;overLibDiagram();return overlib(&#39;UDP_CSR: AT91C_UDP_RXSETUP&#39;)&quot; onmouseout=&quot;return nd();&quot;&gt;</span>
<a name="l00387"></a>00387 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;436,672,600,672,600,698,436,698,436,672&quot; title=&quot;ISR_Vbus&quot;&gt;</span>
<a name="l00388"></a>00388 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;436,539,600,539,600,565,436,565,436,539&quot; title=&quot;ISR_Vbus&quot;&gt;</span>
<a name="l00389"></a>00389 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;482,0,554,0,554,13,482,13,482,0&quot; title=&quot;Applications&quot;&gt;</span>
<a name="l00390"></a>00390 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;278,0,331,0,331,13,278,13,278,0&quot; title=&quot;USBD API&quot;&gt;</span>
<a name="l00391"></a>00391 <span class="comment">&lt;AREA shape=&quot;poly&quot; coords=&quot;36,0,128,0,128,13,36,13,36,0&quot; title=&quot;UDP_, UDPHS_&quot;&gt;</span>
<a name="l00392"></a>00392 <span class="comment">&lt;/MAP&gt;</span>
<a name="l00393"></a>00393 <span class="comment">&lt;IMG SRC=&quot;USBDCallbackInvocationFlowchart.png&quot; border=0 ALT=&quot;USBDCallbackInvocationFlowchart.png&quot; usemap=&quot;#usbd_cb_invo_fc&quot;&gt;</span>
<a name="l00394"></a>00394 <span class="comment">*/</span>
<a name="l00395"></a>00395 <span class="comment"></span>
<a name="l00396"></a>00396 <span class="comment">/**</span>
<a name="l00397"></a>00397 <span class="comment"> \page usbd_callback_api USBD Callback API</span>
<a name="l00398"></a>00398 <span class="comment"></span>
<a name="l00399"></a>00399 <span class="comment"> \section cb_api Callback API</span>
<a name="l00400"></a>00400 <span class="comment"></span>
<a name="l00401"></a>00401 <span class="comment"> The callback API is a means of communication between the user application and</span>
<a name="l00402"></a>00402 <span class="comment"> the USBD API. When particular operations must be performed, the USB driver</span>
<a name="l00403"></a>00403 <span class="comment"> calls serveral external functions, refferred to as &lt;b&gt;callbacks&lt;/b&gt;. They can also</span>
<a name="l00404"></a>00404 <span class="comment"> be invoked to notify the user application of pending events.</span>
<a name="l00405"></a>00405 <span class="comment"></span>
<a name="l00406"></a>00406 <span class="comment"> Defining all callbacks is not mandatory. For example, if the device shall not</span>
<a name="l00407"></a>00407 <span class="comment"> enter low-power mode, then it is appropriate not to provide a Suspend callback.</span>
<a name="l00408"></a>00408 <span class="comment"> If a callback is mandatory, this is notified in its description.</span>
<a name="l00409"></a>00409 <span class="comment"></span>
<a name="l00410"></a>00410 <span class="comment"> See USBDCallbacks.h for callback definitions.</span>
<a name="l00411"></a>00411 <span class="comment"></span>
<a name="l00412"></a>00412 <span class="comment"> \section Callback Invocation</span>
<a name="l00413"></a>00413 <span class="comment"> The following events can trigger a callback:</span>
<a name="l00414"></a>00414 <span class="comment"> - USB initialization: \ref USBDCallbacks_Initialized</span>
<a name="l00415"></a>00415 <span class="comment"> - End of bus reset: \ref USBDCallbacks_Reset</span>
<a name="l00416"></a>00416 <span class="comment"> - Device suspend: \ref USBDCallbacks_Suspended</span>
<a name="l00417"></a>00417 <span class="comment"> - Device resume: \ref USBDCallbacks_Resumed</span>
<a name="l00418"></a>00418 <span class="comment"> - SETUP request received: \ref USBDCallbacks_RequestReceived</span>
<a name="l00419"></a>00419 <span class="comment"> - Start of a new USB frame</span>
<a name="l00420"></a>00420 <span class="comment"></span>
<a name="l00421"></a>00421 <span class="comment"> \image html USBDCallbackInvocationFlowchart.png &quot;Callback Invocation Flowchart&quot;</span>
<a name="l00422"></a>00422 <span class="comment"></span>
<a name="l00423"></a>00423 <span class="comment"> \subsection Init</span>
<a name="l00424"></a>00424 <span class="comment"> The \ref USBDCallbacks_Initialized callback is invoked when the \ref USBD_Init method is</span>
<a name="l00425"></a>00425 <span class="comment"> called. It has to perform several mandatory steps to make it possible to use</span>
<a name="l00426"></a>00426 <span class="comment"> the API:</span>
<a name="l00427"></a>00427 <span class="comment"> - If an OS is used, perform any specific operation to install the driver</span>
<a name="l00428"></a>00428 <span class="comment"> - Configure USB controller interrupt</span>
<a name="l00429"></a>00429 <span class="comment"> - Configure Vbus monitoring PIO and interrupt ( but it&#39;s in app layer now )</span>
<a name="l00430"></a>00430 <span class="comment"> The USB controller interrupt must be configured to &lt;b&gt;call the</span>
<a name="l00431"></a>00431 <span class="comment"> USBD_IrqHandler&lt;/b&gt; API function when triggered. This is necessary to have</span>
<a name="l00432"></a>00432 <span class="comment"> events happening at the USB controller level handled appropriately by the API.</span>
<a name="l00433"></a>00433 <span class="comment"></span>
<a name="l00434"></a>00434 <span class="comment"> If a PIO pin is connected to VBus, it is possible to monitor it by configuring</span>
<a name="l00435"></a>00435 <span class="comment"> the pin as an input and enabling the PIO interrupt. The interrupt service</span>
<a name="l00436"></a>00436 <span class="comment"> routine should simply check the Vbus status and then call the \ref USBD_Connect</span>
<a name="l00437"></a>00437 <span class="comment"> and \ref USBD_Disconnect function to put device into right state.</span>
<a name="l00438"></a>00438 <span class="comment"></span>
<a name="l00439"></a>00439 <span class="comment"> Finally, if an OS is being used, then the driver should probably be installed</span>
<a name="l00440"></a>00440 <span class="comment"> prior to use. Interrupt configuration may also be done differently. Please</span>
<a name="l00441"></a>00441 <span class="comment"> refer to the documentation of the OS for more information.</span>
<a name="l00442"></a>00442 <span class="comment"></span>
<a name="l00443"></a>00443 <span class="comment"> This callback is &lt;b&gt;mandatory&lt;/b&gt;.</span>
<a name="l00444"></a>00444 <span class="comment"></span>
<a name="l00445"></a>00445 <span class="comment"> \subsection Reset</span>
<a name="l00446"></a>00446 <span class="comment"> When an End of bus reset has been detected, the USBDCallbacks_Reset callback</span>
<a name="l00447"></a>00447 <span class="comment"> is triggered. The callback should perform &lt;b&gt;initialization&lt;/b&gt; or &lt;b&gt;re-</span>
<a name="l00448"></a>00448 <span class="comment"> initialization&lt;/b&gt; of the user-level application. For example, a class driver</span>
<a name="l00449"></a>00449 <span class="comment"> like MSD should re-initialize its internal state when a USB reset is performed.</span>
<a name="l00450"></a>00450 <span class="comment"></span>
<a name="l00451"></a>00451 <span class="comment"> \subsection Suspend</span>
<a name="l00452"></a>00452 <span class="comment"> When the USB device enters the Suspended state, the USB API notifies this state</span>
<a name="l00453"></a>00453 <span class="comment"> change by invoking the \ref USBDCallbacks_Suspended callback. This can happen either</span>
<a name="l00454"></a>00454 <span class="comment"> when the bus is idle or when the device is disconnected from the USB.</span>
<a name="l00455"></a>00455 <span class="comment"></span>
<a name="l00456"></a>00456 <span class="comment"> If the device should enter low-power mode when suspended, then this callback</span>
<a name="l00457"></a>00457 <span class="comment"> must perform the required operations to do so, e.g., switching to a slow clock,</span>
<a name="l00458"></a>00458 <span class="comment"> disabling PLLs, etc.</span>
<a name="l00459"></a>00459 <span class="comment"></span>
<a name="l00460"></a>00460 <span class="comment"> - &lt;i&gt;Note: The electrical specification of the USB 2.0 defines a maximum current</span>
<a name="l00461"></a>00461 <span class="comment">    consumption of 500uA for suspended device. This includes the current passing</span>
<a name="l00462"></a>00462 <span class="comment">    through pull-ups and upll-downs.&lt;/i&gt;</span>
<a name="l00463"></a>00463 <span class="comment"></span>
<a name="l00464"></a>00464 <span class="comment"> \subsection Resume</span>
<a name="l00465"></a>00465 <span class="comment"> The \ref USBDCallbacks_Resumed callback is invoked when the USB device leaves the</span>
<a name="l00466"></a>00466 <span class="comment"> Suspended state and returns to its previous state (either Powered, Default,</span>
<a name="l00467"></a>00467 <span class="comment"> Address or Configured). This may happen when activity is detected on the USB,</span>
<a name="l00468"></a>00468 <span class="comment"> or when the device gets connected.</span>
<a name="l00469"></a>00469 <span class="comment"></span>
<a name="l00470"></a>00470 <span class="comment"> If the device was in low-power mode because of the Suspend callback, then this</span>
<a name="l00471"></a>00471 <span class="comment"> callback must perform the necessary poerations to return the device into a</span>
<a name="l00472"></a>00472 <span class="comment"> normal operation mode, e.g., switching to a fast clock.</span>
<a name="l00473"></a>00473 <span class="comment"></span>
<a name="l00474"></a>00474 <span class="comment"> \subsection NewRequest</span>
<a name="l00475"></a>00475 <span class="comment"> When a SETUP request is received on a control endpoint, the USBD API layer</span>
<a name="l00476"></a>00476 <span class="comment"> triggers the USBDCallbacks_RequestReceived callback to notify the user</span>
<a name="l00477"></a>00477 <span class="comment"> application. The received request can then be accessed through the</span>
<a name="l00478"></a>00478 <span class="comment"> corresponding USBGenericRequest structure.</span>
<a name="l00479"></a>00479 <span class="comment"></span>
<a name="l00480"></a>00480 <span class="comment"> SETUP packets are used for class-specific requests (e.g. &lt;i&gt;GetMaxLUN&lt;/i&gt; in MSD)</span>
<a name="l00481"></a>00481 <span class="comment"> as well as standard USB requests (e.g. &lt;i&gt;SetConfiguration&lt;/i&gt;). The former are</span>
<a name="l00482"></a>00482 <span class="comment"> described in &lt;i&gt;USB Device Class Documents&lt;/i&gt;, such as the &lt;i&gt;Mass Storage Bulk</span>
<a name="l00483"></a>00483 <span class="comment"> Only 1.0&lt;/i&gt;, the latter are defined in the USB Specification 2.0.</span>
<a name="l00484"></a>00484 <span class="comment"></span>
<a name="l00485"></a>00485 <span class="comment"> - &lt;i&gt;Note: that SETUP requests which are not understood by the device should</span>
<a name="l00486"></a>00486 <span class="comment">   be acknowledged with a STALL handshake. This notifies the host that the</span>
<a name="l00487"></a>00487 <span class="comment">   device cannot process the command.&lt;/i&gt;</span>
<a name="l00488"></a>00488 <span class="comment"></span>
<a name="l00489"></a>00489 <span class="comment"> This callback is &lt;b&gt;mandatory&lt;/b&gt;.</span>
<a name="l00490"></a>00490 <span class="comment"></span>
<a name="l00491"></a>00491 <span class="comment"> \subsection StartOfFrame</span>
<a name="l00492"></a>00492 <span class="comment"> Every 1ms (for a full-speed device) or 125us (for a high-speed device) a</span>
<a name="l00493"></a>00493 <span class="comment"> new USB frame starts. A callback can be invoked whenever this occurs.</span>
<a name="l00494"></a>00494 <span class="comment"></span>
<a name="l00495"></a>00495 <span class="comment"> Because the start-of-frame interrupt %puts some stress on the processor</span>
<a name="l00496"></a>00496 <span class="comment"> (since it is called a lot), it is only activated the corresponding</span>
<a name="l00497"></a>00497 <span class="comment"> callback is defined (&lt;b&gt;now it&#39;s NOT defined in current framework&lt;/b&gt;).</span>
<a name="l00498"></a>00498 <span class="comment"></span>
<a name="l00499"></a>00499 <span class="comment">*/</span>
<a name="l00500"></a>00500 <span class="comment"></span>
<a name="l00501"></a>00501 <span class="comment">/**</span>
<a name="l00502"></a>00502 <span class="comment"> \page usbd_std_req_handler USBD Standard Request Handler</span>
<a name="l00503"></a>00503 <span class="comment"></span>
<a name="l00504"></a>00504 <span class="comment"> \section Standard Request Handler</span>
<a name="l00505"></a>00505 <span class="comment"></span>
<a name="l00506"></a>00506 <span class="comment"> Chapter 9 of the USB specification 2.0 defines a set of standard requests</span>
<a name="l00507"></a>00507 <span class="comment"> which have to be implemented by all devices. Since most class drivers treat</span>
<a name="l00508"></a>00508 <span class="comment"> those requests in the standard way, the USB framework provides a way to easily</span>
<a name="l00509"></a>00509 <span class="comment"> do that.</span>
<a name="l00510"></a>00510 <span class="comment"></span>
<a name="l00511"></a>00511 <span class="comment"> \section USBDDriver_RequestHandler</span>
<a name="l00512"></a>00512 <span class="comment"></span>
<a name="l00513"></a>00513 <span class="comment"> \ref USBDDriver_RequestHandler handles the standard requests in an appropriate way.</span>
<a name="l00514"></a>00514 <span class="comment"> It can answer the following commands:</span>
<a name="l00515"></a>00515 <span class="comment"></span>
<a name="l00516"></a>00516 <span class="comment"> - GET_DESCRIPTOR</span>
<a name="l00517"></a>00517 <span class="comment"> - SET_ADDRESS</span>
<a name="l00518"></a>00518 <span class="comment"> - SET_CONFIGURATION</span>
<a name="l00519"></a>00519 <span class="comment"> - GET_CONFIGURATION</span>
<a name="l00520"></a>00520 <span class="comment"> - CLEAR_FEATURE</span>
<a name="l00521"></a>00521 <span class="comment"> - SET_FEATURE</span>
<a name="l00522"></a>00522 <span class="comment"> - GET_STATUS</span>
<a name="l00523"></a>00523 <span class="comment"></span>
<a name="l00524"></a>00524 <span class="comment"> Simply using this standard request handler enables a device to be enumerated</span>
<a name="l00525"></a>00525 <span class="comment"> correctly.</span>
<a name="l00526"></a>00526 <span class="comment"></span>
<a name="l00527"></a>00527 <span class="comment"> \subsection get_dsc Get Descriptor</span>
<a name="l00528"></a>00528 <span class="comment"> The GET_DESCRIPTOR request is used by the host to retrieve information about</span>
<a name="l00529"></a>00529 <span class="comment"> the device by means of several descriptors.</span>
<a name="l00530"></a>00530 <span class="comment"></span>
<a name="l00531"></a>00531 <span class="comment"> The standard request handler simply sends the corresponding descriptor to the</span>
<a name="l00532"></a>00532 <span class="comment"> host. How these descriptors are provided to the function is discussed in</span>
<a name="l00533"></a>00533 <span class="comment"> Structures.</span>
<a name="l00534"></a>00534 <span class="comment"></span>
<a name="l00535"></a>00535 <span class="comment"> \subsection set_addr Set Address</span>
<a name="l00536"></a>00536 <span class="comment"> Whenever the host wants to change the device state from Default to Address, or</span>
<a name="l00537"></a>00537 <span class="comment"> vice-versa, it sends a SET_ADDRESS request. The wValue field contains the new</span>
<a name="l00538"></a>00538 <span class="comment"> address of the device; if it is null, then the device returns to the Default</span>
<a name="l00539"></a>00539 <span class="comment"> state.</span>
<a name="l00540"></a>00540 <span class="comment"></span>
<a name="l00541"></a>00541 <span class="comment"> The \ref USBD_SetAddress function is called to perform this operation. Note that a</span>
<a name="l00542"></a>00542 <span class="comment"> zero-length packet must be sent prior to doing that, to acknowledge the SETUP</span>
<a name="l00543"></a>00543 <span class="comment"> transfer.</span>
<a name="l00544"></a>00544 <span class="comment"></span>
<a name="l00545"></a>00545 <span class="comment"> \subsection cfg Set Configuration &amp; GetConfiguration</span>
<a name="l00546"></a>00546 <span class="comment"> The SET_CONFIGURATION request makes it possible for the host to select between</span>
<a name="l00547"></a>00547 <span class="comment"> one or more configurations for the device. GET_CONFIGURATION is used to</span>
<a name="l00548"></a>00548 <span class="comment"> retrieve the currently selected one.</span>
<a name="l00549"></a>00549 <span class="comment"></span>
<a name="l00550"></a>00550 <span class="comment"> Those two requests are handled in a very basic way by</span>
<a name="l00551"></a>00551 <span class="comment"> USBDDriver_RequestHandler() : it assumes that the device has only one</span>
<a name="l00552"></a>00552 <span class="comment"> configuration. Therefore, the SET_CONFIGURATION request is simply acknowledged</span>
<a name="l00553"></a>00553 <span class="comment"> with a zero-length packet, and GET_CONFIGURATION is answered with either 0</span>
<a name="l00554"></a>00554 <span class="comment"> or 1. If the user application needs more than one configuration, it will be</span>
<a name="l00555"></a>00555 <span class="comment"> the duty of the class driver handler to service those requests.</span>
<a name="l00556"></a>00556 <span class="comment"></span>
<a name="l00557"></a>00557 <span class="comment"> In addition, when the SET_CONFIGURATION request causes the device to enter the</span>
<a name="l00558"></a>00558 <span class="comment"> Configured state, the standard request handler calls the USBD_ConfigureEndpoint</span>
<a name="l00559"></a>00559 <span class="comment"> method for each endpoint used by the device;</span>
<a name="l00560"></a>00560 <span class="comment"></span>
<a name="l00561"></a>00561 <span class="comment"> \subsection feature Clear Feature, Set Feature &amp; Get Status</span>
<a name="l00562"></a>00562 <span class="comment"> Several features of a device can either be activated or deactivated by the USB</span>
<a name="l00563"></a>00563 <span class="comment"> host:</span>
<a name="l00564"></a>00564 <span class="comment"> - Remote wakeup</span>
<a name="l00565"></a>00565 <span class="comment"> - Endpoint Halt state</span>
<a name="l00566"></a>00566 <span class="comment"> Three requests can be used to either set, clear or get the status of these two</span>
<a name="l00567"></a>00567 <span class="comment"> features: SET_FEATURE, CLEAR_FEATURE and GET_STATUS.</span>
<a name="l00568"></a>00568 <span class="comment"> </span>
<a name="l00569"></a>00569 <span class="comment"> The \ref USBDDriver_RequestHandler method answers a Halt state operation by calling</span>
<a name="l00570"></a>00570 <span class="comment"> the \ref USBD_Halt method on the endpoint with the request.</span>
<a name="l00571"></a>00571 <span class="comment"></span>
<a name="l00572"></a>00572 <span class="comment"> \section Structures</span>
<a name="l00573"></a>00573 <span class="comment"> Several pieces of information must be known to the \ref USBDDriver_RequestHandler</span>
<a name="l00574"></a>00574 <span class="comment"> to be able to process some SETUP commands. For example, all the descriptors</span>
<a name="l00575"></a>00575 <span class="comment"> (configuration, etc.) used by the device are needed since they must be sent</span>
<a name="l00576"></a>00576 <span class="comment"> to the host when a GET_DESCRIPTOR is received.</span>
<a name="l00577"></a>00577 <span class="comment"></span>
<a name="l00578"></a>00578 <span class="comment"> The \ref USBGenericRequest structure is a &quot;standard USB class driver&quot; object used</span>
<a name="l00579"></a>00579 <span class="comment"> to hold the required information. It must be passed as an argument to the</span>
<a name="l00580"></a>00580 <span class="comment"> \ref USBDDriver_RequestHandler method. Another structure, \ref USBDDriverDescriptors, is</span>
<a name="l00581"></a>00581 <span class="comment"> used to store the descriptors list.</span>
<a name="l00582"></a>00582 <span class="comment"></span>
<a name="l00583"></a>00583 <span class="comment"> \section Usage</span>
<a name="l00584"></a>00584 <span class="comment"> The NewRequest callback is used to notify the user application that a new SETUP</span>
<a name="l00585"></a>00585 <span class="comment"> request has been received. SETUP request can either be class-specific or</span>
<a name="l00586"></a>00586 <span class="comment"> standard.</span>
<a name="l00587"></a>00587 <span class="comment"></span>
<a name="l00588"></a>00588 <span class="comment"> The correct way to handle incoming requests is to first process class-specific</span>
<a name="l00589"></a>00589 <span class="comment"> requests using a class handler. For example, a Mass Storage implementation will</span>
<a name="l00590"></a>00590 <span class="comment"> define the NewRequest callback to call \ref MSDDriver_RequestHandler. This function</span>
<a name="l00591"></a>00591 <span class="comment"> will handle the necessary requests, and forward the rest to</span>
<a name="l00592"></a>00592 <span class="comment"> \ref USBDDriver_RequestHandler.</span>
<a name="l00593"></a>00593 <span class="comment"></span>
<a name="l00594"></a>00594 <span class="comment"> If a request cannot be processed, \ref USBDDriver_RequestHandler will STALL control</span>
<a name="l00595"></a>00595 <span class="comment"> endpoint 0.</span>
<a name="l00596"></a>00596 <span class="comment"></span>
<a name="l00597"></a>00597 <span class="comment">*/</span>
<a name="l00598"></a>00598 <span class="comment"></span>
<a name="l00599"></a>00599 <span class="comment">/**</span>
<a name="l00600"></a>00600 <span class="comment"> \page usbd_id_str USBD VID, PID, SN &amp; Strings</span>
<a name="l00601"></a>00601 <span class="comment"></span>
<a name="l00602"></a>00602 <span class="comment"> This page collects the definition for USB device to indicate the Vendor and</span>
<a name="l00603"></a>00603 <span class="comment"> Product information.</span>
<a name="l00604"></a>00604 <span class="comment"></span>
<a name="l00605"></a>00605 <span class="comment"></span>
<a name="l00606"></a>00606 <span class="comment"> If you need only the functions in demo %driver, you can easily modify these</span>
<a name="l00607"></a>00607 <span class="comment"> definitions to change your device&#39;s Identification and Display strings.</span>
<a name="l00608"></a>00608 <span class="comment"></span>
<a name="l00609"></a>00609 <span class="comment"> They are defined in the driver c code file that suffixed with</span>
<a name="l00610"></a>00610 <span class="comment"> &quot;DriverDescriptors&quot; under the driver directory.</span>
<a name="l00611"></a>00611 <span class="comment"></span>
<a name="l00612"></a>00612 <span class="comment"> \section usbd_id_str_desc VID, PID &amp; SN in Device Descriptor</span>
<a name="l00613"></a>00613 <span class="comment"></span>
<a name="l00614"></a>00614 <span class="comment"> Defined as const and used in \ref USBDeviceDescriptor instance initialization.</span>
<a name="l00615"></a>00615 <span class="comment"> Gives identivication to the USB device by VID and PID. The INF installation</span>
<a name="l00616"></a>00616 <span class="comment"> file should mach the VID &amp; PID so that the device can be installed.</span>
<a name="l00617"></a>00617 <span class="comment"></span>
<a name="l00618"></a>00618 <span class="comment">\code</span>
<a name="l00619"></a>00619 <span class="comment">const USBDeviceDescriptor deviceDescriptor = {...};</span>
<a name="l00620"></a>00620 <span class="comment">\endcode</span>
<a name="l00621"></a>00621 <span class="comment"></span>
<a name="l00622"></a>00622 <span class="comment"> - audio-speaker: &quot;Audio Speaker Device Codes&quot;</span>
<a name="l00623"></a>00623 <span class="comment"> - ccid: &quot;CCID Device IDs&quot;</span>
<a name="l00624"></a>00624 <span class="comment"> - cdc-serial: &quot;CDC Serial Device IDs&quot;</span>
<a name="l00625"></a>00625 <span class="comment"> - hid-keyboard: &quot;HID Device Descriptor IDs&quot;</span>
<a name="l00626"></a>00626 <span class="comment"> - massstorage: &quot;MSD Device Descriptor IDs&quot;</span>
<a name="l00627"></a>00627 <span class="comment"></span>
<a name="l00628"></a>00628 <span class="comment"> \section Strings</span>
<a name="l00629"></a>00629 <span class="comment"></span>
<a name="l00630"></a>00630 <span class="comment"> The strings gives additional information on the USB device, normally string</span>
<a name="l00631"></a>00631 <span class="comment"> description about the vendor, product and serial number.</span>
<a name="l00632"></a>00632 <span class="comment"></span>
<a name="l00633"></a>00633 <span class="comment"> The strings are defined as a list to initialize the driver&#39;s</span>
<a name="l00634"></a>00634 <span class="comment"> \ref USBDDriverDescriptors instance:</span>
<a name="l00635"></a>00635 <span class="comment"></span>
<a name="l00636"></a>00636 <span class="comment"> - audio-speaker: auddSpeakerDriverDescriptors</span>
<a name="l00637"></a>00637 <span class="comment"> - ccid: ccidDriverDescriptors</span>
<a name="l00638"></a>00638 <span class="comment"> - cdc-serial: cdcdSerialDriverDescriptors</span>
<a name="l00639"></a>00639 <span class="comment"> - hid-keyboard: hiddKeyboardDriverDescriptors</span>
<a name="l00640"></a>00640 <span class="comment"> - massstorage: msdDriverDescriptors</span>
<a name="l00641"></a>00641 <span class="comment"></span>
<a name="l00642"></a>00642 <span class="comment">\code</span>
<a name="l00643"></a>00643 <span class="comment">// String descriptors</span>
<a name="l00644"></a>00644 <span class="comment">const unsigned char *stringDescriptors[] = {</span>
<a name="l00645"></a>00645 <span class="comment"></span>
<a name="l00646"></a>00646 <span class="comment">    languageIdDescriptor,</span>
<a name="l00647"></a>00647 <span class="comment">    manufacturerDescriptor,</span>
<a name="l00648"></a>00648 <span class="comment">    productDescriptor,</span>
<a name="l00649"></a>00649 <span class="comment">    serialNumberDescriptor,</span>
<a name="l00650"></a>00650 <span class="comment">};</span>
<a name="l00651"></a>00651 <span class="comment">\endcode</span>
<a name="l00652"></a>00652 <span class="comment">*/</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
