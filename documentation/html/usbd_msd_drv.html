<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAM3S Software Package: USB Device Massstorage Driver</title>
<link href="common/style.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
    <div id="body">
        <div id="title">SAM3S Software Package 2.1</div>
        <div id="banner"></div>

<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="usb_library.html">USB Library</a>      </li>
      <li><a class="el" href="usbd_framework.html">AT91 USB device framework</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>USB Device Massstorage Driver </h1>  </div>
</div>
<div class="contents">
<p>This page describes how to use the USB framework to produce a USB Device MSD driver, which appears as a USB Disk on host.</p>
<h2><a class="anchor" id="References"></a>
References</h2>
<ul>
<li><a class="el" href="usbd_framework.html">AT91 USB device framework</a></li>
<li><a class="el" href="usbd_enum.html">USB Device Enumeration</a></li>
<li><a href="http://www.usb.org/developers/docs/usb_20_040908.zip">Universal Serial Bus Revision 2.0 specification </a> (.zip file format, size 9.80 MB)</li>
<li><a href="http://www.usb.org/developers/devclass_docs/usb_msc_overview_1.2.pdf">Mass Storage Overview 1.2</a></li>
<li><a href="http://www.usb.org/developers/devclass_docs/usbmassbulk_10.pdf">Mass Storage Bulk Only 1.0</a></li>
<li><a href="http://www.t10.org/scsi-3.htm">SCSI Standards</a><ul>
<li>SCSI Block Commands - 3 (SBC-3)</li>
<li>SCSI Primary Commands - 4 (SPC-4)</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="msc_basic"></a>
Mass Storage Class Basic</h2>
<p>This section gives generic details on the MSD class.</p>
<p>See <a class="el" href="usb_msd_basic.html">USB MSD Basic</a>.</p>
<h2><a class="anchor" id="msc_scsi_disk"></a>
Mass Storage SCSI Disk</h2>
<p>This section describes how to implement a USB disk by using the MSD class with the SCSI transparent command set and the AT91 USB Framework. For more information about the framework, please refer to the "AT91 USB device
 framework" application note; details about the USB and the Mass Storage class can be found in the USB specification 2.0 and the MSC Bulk-Only Transport specification 1.0 documents, respectively.</p>
<p>The software example provided with this document uses the ram disk of the chip as its storage medium, but has been designed in a modular way to allow easy modification for any medium, e.g. internal flash, DataFlash, SD card, external Flash chip.</p>
<h3><a class="anchor" id="Architecture"></a>
Architecture</h3>
<p>The MSD driver is based on framework, See <a class="el" href="usbd_framework_arch.html">USB Device Framework Architecture</a>.</p>
<p>The internal architecture of the Application layer is extended for the following factors:</p>
<ul>
<li>The Command/Data/Status flow described in <a class="el" href="usb_msd_basic.html">USB MSD Basic</a> requires the use of a <b>state machine</b> for non-blocking operation.</li>
<li>The example software has been designed to be easily extended with support for other media.</li>
<li>The example software has been designed to support multiple LUNs on one or more media.</li>
</ul>
<div align="center">
<img src="MSDAppArch.png" alt="MSDAppArch.png"/>
<p><strong>Application Layer Architecture</strong></p></div>
 <h3><a class="anchor" id="Descriptors"></a>
Descriptors</h3>
<p>There are no class-specific descriptors for a device using the MSD class with the Bulk-only transport protocol. This section thus only details the values which must be set in the standard descriptors.</p>
<h4><a class="anchor" id="dev_dsc"></a>
Device Descriptor</h4>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keyword">const</span> USBDeviceDescriptor deviceDescriptor = {

    <span class="keyword">sizeof</span>(USBDeviceDescriptor), <span class="comment">// bLength: Size of descriptor (18 bytes)</span>
    <a class="code" href="group__usb__desc__type.html#ga6363c61655b33b6312f0de0f317528e3">USBGenericDescriptor_DEVICE</a>, <span class="comment">// bDescriptorType: Device descriptor</span>
    <a class="code" href="group__usb__release__number.html#ga69167f83b560d92391cf222d9d3690de">USBDeviceDescriptor_USB2_00</a>, <span class="comment">// bcdUSB: USB 2.00</span>
    <a class="code" href="group__usbd__ms__device__codes.html#ga3c42c7e18f1325877f70933aac0f3139">MSDeviceDescriptor_CLASS</a>,    <span class="comment">// bDeviceClass: 0</span>
    <a class="code" href="group__usbd__ms__device__codes.html#gaded09d1e1da92b623c322fb6bb375678">MSDeviceDescriptor_SUBCLASS</a>, <span class="comment">// bDeviceSubClass: 0</span>
    <a class="code" href="group__usbd__ms__device__codes.html#ga9ab87cd28acd2322d38cc9e95a1d0175">MSDeviceDescriptor_PROTOCOL</a>, <span class="comment">// bDeviceProtocol: 0</span>
    BOARD_USB_ENDPOINTS_MAXPACKETSIZE(0), <span class="comment">// bMaxPacketSize0: Max Size EP0</span>
    MSDDriverDescriptors_VENDORID, <span class="comment">// idVendor: Vendor ID ATMEL (0x03eb)</span>
    MSDDriverDescriptors_PRODUCTID,<span class="comment">// idProduct: Product ID (0x6202)</span>
    MSDDriverDescriptors_RELEASE,  <span class="comment">// bcdDevice: 0x0001, Version 0.01</span>
    1, <span class="comment">// iManufacturer: Manufacturer string (manufacturerDescriptor) index.</span>
    2, <span class="comment">// iProduct: Product string (productDescriptor) index.</span>
    3, <span class="comment">// iSerialNumber: Serial number string (serialNumberDescriptor) index.</span>
    1  <span class="comment">// bNumConfigurations: Device has one possible configuration.</span>
};
</pre></div><p> Note that the Vendor ID is a special value attributed by the USB-IF organization. The product ID can be chosen freely by the vendor.</p>
<h4><a class="anchor" id="cfg_dsc"></a>
Configuration Descriptor</h4>
<p>The descriptors are defined as: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> MSDConfigurationDescriptors <a class="code" href="group__usbd__cdc.html#gafd15c3aa6fce2192be56c41854338f2d">configurationDescriptorsFS</a>;
</pre></div><p>Configuration descriptor </p>
<div class="fragment"><pre class="fragment"><span class="comment">// Standard configuration descriptor.</span>
{
    <span class="keyword">sizeof</span>(USBConfigurationDescriptor), <span class="comment">// bLength: 9 bytes</span>
    <a class="code" href="group__usb__desc__type.html#ga3a0e7ca09c79c9b17866b19770d7dfe7">USBGenericDescriptor_CONFIGURATION</a>, <span class="comment">// bDescriptorType: Configuration</span>
    <span class="keyword">sizeof</span>(MSDConfigurationDescriptors),<span class="comment">// wTotalLength: Length of all</span>
    1, <span class="comment">// bNumInterface: Configuration has one interface.</span>
    1, <span class="comment">// bConfigurationValue: This is configuration #1.</span>
    0, <span class="comment">// iConfiguration: No string descriptor for configuration.</span>
    BOARD_USB_BMATTRIBUTES, <span class="comment">// bmAttributes: Power and remote wakeup</span>
    <a class="code" href="group__usb__attributes.html#gab63528cba8ea4c8178d79393caa5d5f1">USBConfigurationDescriptor_POWER</a>(100) <span class="comment">// 100mA max power</span>
},
</pre></div><h4><a class="anchor" id="if_dsc"></a>
Interface Descriptor</h4>
<p>The interface descriptor must indicate several features:</p>
<ul>
<li><b>Mass Storage Device</b> class code (08h) in the <em>bInterfaceClass</em> field</li>
<li><b>Data Transport Protocol</b> code in the <em>bInterfaceSubclass</em> field</li>
<li><b>Bulk-Only Transport</b> protocol code (50h) in the <em>bInterfaceProtocol</em> field This example uses the SCSI transparent command set (code 06h). This is the most appropriate setting for a Flash device, given that the RBC command set is not supported by Microsoft Windows. <div class="fragment"><pre class="fragment"><span class="comment">// Mass Storage interface descriptor.</span>
{
    <span class="keyword">sizeof</span>(USBInterfaceDescriptor), <span class="comment">// bLength: Size of descriptor(9 bytes)</span>
    <a class="code" href="group__usb__desc__type.html#ga82c82ea74c0f8b487812ad73cc5ed4a4">USBGenericDescriptor_INTERFACE</a>, <span class="comment">// bDescriptorType: Interface descriptor</span>
    0, <span class="comment">// bInterfaceNumber: This is interface #0.</span>
    0, <span class="comment">// bAlternateSetting: This is alternate setting #0.</span>
    2, <span class="comment">// bNumEndpoints: Interface uses two endpoints.</span>
    <a class="code" href="group__usb__ms__interface__code.html#ga790932975f6d50909b25d60eba7dfecb">MSInterfaceDescriptor_CLASS</a>, <span class="comment">// bInterfaceClass: Mass Storage Device Class</span>
    <a class="code" href="group__usb__ms__interface__code.html#ga3b68f316598725ee1f7bdd469ac0f430">MSInterfaceDescriptor_SCSI</a>, <span class="comment">// bInterfaceSubClass: SCSI transparent command</span>
    <a class="code" href="group__usb__ms__interface__code.html#gab9243e706daf47eb37d98dd78d56d654">MSInterfaceDescriptor_BULKONLY</a>,<span class="comment">// bInterfaceProtocol: Bulk-Only transport</span>
    0 <span class="comment">// iInterface: No string descriptor for interface.</span>
},
</pre></div></li>
</ul>
<h4><a class="anchor" id="ep_dsc"></a>
Endpoint Descriptors</h4>
<p>No special requirements on these apart from being Bulk-IN and Bulk-OUT. </p>
<div class="fragment"><pre class="fragment"><span class="comment">// Bulk-OUT endpoint descriptor</span>
{
    <span class="keyword">sizeof</span>(USBEndpointDescriptor), <span class="comment">// bLength: 7 bytes</span>
    <a class="code" href="group__usb__desc__type.html#gad3370279f99871dff82504dcef7691d9">USBGenericDescriptor_ENDPOINT</a>, <span class="comment">// bDescriptorType: Endpoint descriptor</span>
    <a class="code" href="group__usb__ep__addr.html#ga97750e5e90d44f3732090a2ecc4f54f2">USBEndpointDescriptor_ADDRESS</a>(
        <a class="code" href="group__usb__ep__dir.html#gabc4606a47dbae4a95b77a0a4c8dd2533">USBEndpointDescriptor_OUT</a>,
        <a class="code" href="group__usbd__msdd__config.html#ga3cdfe4df582ad8c8b85f38c5124ce2da">MSDDriverDescriptors_BULKOUT</a>), <span class="comment">// bEndpointAddress: OUT 0x01</span>
    USBEndpointDescriptor_BULK, <span class="comment">// bmAttributes: Bulk endpoint</span>
    <a class="code" href="group__usbd__cdc.html#ga3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>(BOARD_USB_ENDPOINTS_MAXPACKETSIZE(<a class="code" href="group__usbd__msdd__config.html#ga3cdfe4df582ad8c8b85f38c5124ce2da">MSDDriverDescriptors_BULKOUT</a>),
        <a class="code" href="group__usb__ep__size.html#gac895f7eda6272a0cac38a6fd5d5b63d8">USBEndpointDescriptor_MAXBULKSIZE_FS</a>), <span class="comment">// wMaxPacketSize: 64 bytes</span>
    0 <span class="comment">// bInterval: Must be 0 for full-speed Bulk endpoints.</span>
},
<span class="comment">// Bulk-IN endpoint descriptor</span>
{
    <span class="keyword">sizeof</span>(USBEndpointDescriptor), <span class="comment">// bLength: 7 bytes</span>
    <a class="code" href="group__usb__desc__type.html#gad3370279f99871dff82504dcef7691d9">USBGenericDescriptor_ENDPOINT</a>, <span class="comment">// bDescriptorType: Endpoint descriptor</span>
    <a class="code" href="group__usb__ep__addr.html#ga97750e5e90d44f3732090a2ecc4f54f2">USBEndpointDescriptor_ADDRESS</a>(
        <a class="code" href="group__usb__ep__dir.html#ga833932f6a610e222c9f304b88253e27c">USBEndpointDescriptor_IN</a>,
        <a class="code" href="group__usbd__msdd__config.html#ga04bc2dac2c0377bca6b5db25053c94e6">MSDDriverDescriptors_BULKIN</a>), <span class="comment">// bEndpointAddress: IN 0x82</span>
    USBEndpointDescriptor_BULK, <span class="comment">// bmAttributes: Bulk endpoint</span>
    <a class="code" href="group__usbd__cdc.html#ga3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>(BOARD_USB_ENDPOINTS_MAXPACKETSIZE(<a class="code" href="group__usbd__msdd__config.html#ga04bc2dac2c0377bca6b5db25053c94e6">MSDDriverDescriptors_BULKIN</a>),
        <a class="code" href="group__usb__ep__size.html#gac895f7eda6272a0cac38a6fd5d5b63d8">USBEndpointDescriptor_MAXBULKSIZE_FS</a>), <span class="comment">// wMaxPacketSize: 64</span>
    0 <span class="comment">// bInterval: Must be 0 for full-speed Bulk endpoints.</span>
}
</pre></div><h4><a class="anchor" id="str_dsc"></a>
String descriptors</h4>
<p>Several descriptors can be commented with a String descriptor. The latter are completely optional and do not influence the detection of the device by the operating system. Whether or not to include them is entirely up to the programmer.</p>
<p>There is one exception to this rule when using the MSD class. According to the specification, there must be a Serial Number string. It must contains at least 12 characters, and these characters must only be either letters (a-z, A-Z) or numbers (0-9). This cause no problem for the driver in practice, but this is a strict requirement for certification. Also remember that string descriptors use the Unicode format.</p>
<p>See <a class="el" href="group__usbd__cdc__aud.html#ga2af674d5c88b85ff120d12c8c0ab6748">manufacturerDescriptor</a>, <a class="el" href="group__usbd__cdc__aud.html#ga4b20dfbb20cddcd882cb807a6dd8319f">productDescriptor</a>, <a class="el" href="group__usbd__cdc__aud.html#ga53eb66114aeac0731761be191d586fca">serialNumberDescriptor</a>.</p>
<h3><a class="anchor" id="Class-specific"></a>
Requests</h3>
<p>There are two Mass Storage-specific requests:</p>
<ul>
<li>GetMaxLUN</li>
<li>Bulk-Only Mass Storage Reset</li>
</ul>
<p>Standard requests can be forwarded to the <a class="el" href="usbd_std_req_handler.html#USBDDriver_RequestHandler">USBDDriver_RequestHandler</a>, with one exception: <b>CLEAR_FEATURE</b>. This is necessary for Reset Recovery sequence.</p>
<h4><a class="anchor" id="ClearFeature"></a>
ClearFeature</h4>
<p>As previously stated, the CLEAR_FEATURE request must be handled in a particular way, depending on whether or not the device is waiting for a Reset Recovery sequence. If it is, then CLEAR_FEATURE requests to unhalt a Bulk endpoint must be discarded.</p>
<p>In the example software, this behavior is indicated by a boolean field in the driver structure, named waitResetRecovery. The handler only has to check this field value to decide whether to forward the request to the standard handler or to discard it. </p>
<div class="fragment"><pre class="fragment"><span class="comment">// Handle requests</span>
<span class="keywordflow">switch</span> (<a class="code" href="group__usb__request.html#gace388a4d862a1a39dfce506fe4189e82">USBGenericRequest_GetRequest</a>(request)) {
<span class="comment">//---------------------</span>
<span class="keywordflow">case</span> <a class="code" href="group__usb__request__code.html#gac9d090a1d7e05afcb5e6ab6fba86c712">USBGenericRequest_CLEARFEATURE</a>:
<span class="comment">//---------------------</span>

    <span class="keywordflow">switch</span> (<a class="code" href="group__usb__request.html#ga45fc2dc20e20b098a487d3cdc7f1b35e">USBFeatureRequest_GetFeatureSelector</a>(request)) {

    <span class="comment">//---------------------</span>
    <span class="keywordflow">case</span> <a class="code" href="group__usb__feature__sel.html#gaf81fead1b1401b1ebc662369ba81544f">USBFeatureRequest_ENDPOINTHALT</a>:
    <span class="comment">//---------------------</span>

        <span class="comment">// Do not clear the endpoint halt status if the device is waiting</span>
        <span class="comment">// for a reset recovery sequence</span>
        <span class="keywordflow">if</span> (!msdDriver.waitResetRecovery) {

            <span class="comment">// Forward the request to the standard handler</span>
            <a class="code" href="group__usbd__interface.html#gaae0893893739fb365d088ea946cb2c89">USBDDriver_RequestHandler</a>(&amp;<a class="code" href="usb_2usb__core_2main_8c.html#a3e181c734ec3f57f4bb7eaa3c6bf97dc">usbdDriver</a>, request);
        }

        <a class="code" href="group__usbd__interface.html#gafc4728f4af70056b3a271f333b759592">USBD_Write</a>(0, 0, 0, 0, 0);
        <span class="keywordflow">break</span>;

    <span class="comment">//------</span>
    <span class="keywordflow">default</span>:
    <span class="comment">//------</span>
        <span class="comment">// Forward the request to the standard handler</span>
        <a class="code" href="group__usbd__interface.html#gaae0893893739fb365d088ea946cb2c89">USBDDriver_RequestHandler</a>(&amp;<a class="code" href="usb_2usb__core_2main_8c.html#a3e181c734ec3f57f4bb7eaa3c6bf97dc">usbdDriver</a>, request);
    }
    <span class="keywordflow">break</span>;
}
</pre></div><h4><a class="anchor" id="GetMaxLUN"></a>
GetMaxLUN</h4>
<p>Usually, the first request issued by the host right after the enumeration phase will be a GET_MAX_LUN request. It enables it to discover how many different logical units the device has; each of these LUNs can then be queried in turn by the host when needed.</p>
<p>After the request is received by the device, it should return one byte of data indicating the maximum Logical Unit Number (LUN). It is equal to the number of LUNs used by the device minus one. For example, a device with three LUNs shall return a GET_MAX_LUN value of two.</p>
<p>Sending this byte is done by calling the <a class="el" href="usbd_api_method.html#USBD_Write">USBD_Write</a> method on Control endpoint 0. Note that the data must be held in a permanent buffer (since the transfer is asynchronous); in the software provided with this application note, a dedicated field is used in the driver structure (<a class="el" href="struct_m_s_d_driver.html">MSDDriver</a>) to store this value.</p>
<p>In addition due to the <em>Mass Storage Bulk-Only Transport</em> specification the <em>wValue</em> should be 0, <em>wLength</em> should be 1, <em>wIndex</em> should be the interface number also 0. A request which does not comply to these requirements must be STALLed. </p>
<div class="fragment"><pre class="fragment"><span class="comment">//-------------------</span>
<span class="keywordflow">case</span> <a class="code" href="group__usbd__msd.html#ga058396b6f11778e38488216afe4535f9">MSD_GET_MAX_LUN</a>:
<span class="comment">//-------------------</span>
    <span class="comment">// Check request parameters</span>
    <span class="keywordflow">if</span> ((request-&gt;wValue == 0)
        &amp;&amp; (request-&gt;wIndex == 0)
        &amp;&amp; (request-&gt;wLength == 1)) {
        <a class="code" href="group__usbd__interface.html#gafc4728f4af70056b3a271f333b759592">USBD_Write</a>(0, &amp;(msdDriver.maxLun), 1, 0, 0);
    }
    <span class="keywordflow">else</span> {
        <a class="code" href="group__usbd__interface.html#gad846cf5a2a002f83abe01d17d233f644">USBD_Stall</a>(0);
    }
    <span class="keywordflow">break</span>;
</pre></div><h4><a class="anchor" id="Bulk-Only"></a>
Mass Storage Reset</h4>
<p>The host issues <b>RESET</b> requests to return the MSD driver of the device to its initial state, i.e., ready to receive a new command. However, this request does not impact the USB controller state; in particular, endpoints must not be reset. This means the data toggle bit must not be altered, and Halted endpoint must not be returned to a normal state. After processing the reset, the device must return a Zero-Length Packet (ZLP) to acknowledge the SETUP transfer.</p>
<p>Like GET_MAX_LUN, this request must be issued with specific parameters - wValue, wIndex and wLength should be zero. A request which does not have valid values in its field must be acknowledged with a STALL handshake from the device.</p>
<p>The handler for this request must return the state machine to its initial state. </p>
<div class="fragment"><pre class="fragment"><span class="comment">//-----------------------</span>
<span class="keywordflow">case</span> <a class="code" href="group__usbd__msd.html#ga73efc8e5f6c52233931de0f792e4d44f">MSD_BULK_ONLY_RESET</a>:
<span class="comment">//-----------------------</span>
    <span class="comment">// Check parameters</span>
    <span class="keywordflow">if</span> ((request-&gt;wValue == 0)
        &amp;&amp; (request-&gt;wIndex == 0)
        &amp;&amp; (request-&gt;wLength == 0)) {

        <span class="comment">// Reset the MSD driver</span>
        MSDDriver_Reset();
        <a class="code" href="group__usbd__interface.html#gafc4728f4af70056b3a271f333b759592">USBD_Write</a>(0, 0, 0, 0, 0);
    }
    <span class="keywordflow">else</span> {
        <a class="code" href="group__usbd__interface.html#gad846cf5a2a002f83abe01d17d233f644">USBD_Stall</a>(0);
    }
    <span class="keywordflow">break</span>;
</pre></div><h3><a class="anchor" id="state_machine"></a>
State Machine</h3>
<p>...</p>
<h4><a class="anchor" id="Rationale"></a>
Rationale</h4>
<p>A state machine is necessary for <b>non-blocking</b> operation of the driver. As previously stated, there are three steps when processing a command:</p>
<ul>
<li>Reception of the CBW</li>
<li>Processing of the command (with data transfers if required)</li>
<li>Emission of the CSW</li>
</ul>
<p>Without a state machine, the program execution would be stopped at each step to wait for transfers completion or command processing. For example, reception of a CBW does not always happen immediately (the host does not have to issue commands regularly) and can block the system for a long time.</p>
<p>Developing an asynchronous design based on a state machine is made easier when using Atmel <a class="el" href="usbd_framework.html">AT91 USB device framework</a>, as most methods are asynchronous. For example, a write operation (using the <a class="el" href="usbd_api_method.html#USBD_Write">USBD_Write</a> function) returns immediately; a callback function can then be invoked when the transfer actually completes.</p>
<h4><a class="anchor" id="States"></a>
States</h4>
<p>Apart from the three states corresponding to the command processing flow (CBW, command processing and CSW), two more can be identified. The reception/emission of CBW/CSW will be broken down into two different states: the first state is used to issue the read/write operation, while the second one waits for the transfer to finish. This can be done by monitoring a "transfer complete" flag which is set using a callback function.</p>
<p>In addition, some commands can be quite complicated to process: they may require several consecutive data transfers mixed with media access. Each command thus has its own second-tier state machine. During execution of a command, the main state machine remains in the "processing" state, and proceeds to the next one (CSW emission) only when the command is complete.</p>
<p>Here is the states list:</p>
<ul>
<li><a class="el" href="group__usbd__msd__driver__possible__states.html#ga4438be188193362974b17f91d3fb7c0f">MSDD_STATE_READ_CBW</a> : Start of CBW reception (initial state after reset)</li>
<li><a class="el" href="group__usbd__msd__driver__possible__states.html#ga31119a29c0bb1030f5858788133a9f19">MSDD_STATE_WAIT_CBW</a> : Waiting for CBW reception</li>
<li><a class="el" href="group__usbd__msd__driver__possible__states.html#ga67608dacdd0cfb01e1671c546d8cc44e">MSDD_STATE_PROCESS_CBW</a> : Command processing</li>
<li><a class="el" href="group__usbd__msd__driver__possible__states.html#gadc35d496eed9e672951d6e99eb38b42b">MSDD_STATE_SEND_CSW</a> : Start of CSW emission</li>
<li><a class="el" href="group__usbd__msd__driver__possible__states.html#ga88259e0a67d0dc45a54a59ebfab9bb11">MSDD_STATE_WAIT_CSW</a> : Waiting for CSW emission</li>
</ul>
<p>A single function, named MSDDriver_StateMachine, is provided by the driver. It must be called regularly during the program execution. The following subsections describe the actions that must be performed during each state.</p>
<div align="center">
<img src="MSDDriverStates.png" alt="MSDDriverStates.png"/>
<p><strong>MSD Driver State Machine</strong></p></div>
<p> <b>MSDD_STATE_READ_CBW</b></p>
<p>As said previously, this state is used to start the reception of a new Command Block Wrapper. This is done using the <a class="el" href="group__usbd__interface.html#gaa786fa9bbfd3c2f64b5f486e537ffebb">USBD_Read()</a> method of the USB framework. The result code of the function is checked for any error; the <a class="el" href="group__usbd__rc.html#ga4638d75610d787870c2593d231c05b13">USBD_STATUS_SUCCESS</a> code indicates that the transfer has been successfully started. </p>
<div class="fragment"><pre class="fragment"><span class="comment">//----------------------</span>
<span class="keywordflow">case</span> <a class="code" href="group__usbd__msd__driver__possible__states.html#ga4438be188193362974b17f91d3fb7c0f" title="Driver is expecting a command block wrapper.">MSDD_STATE_READ_CBW</a>:
<span class="comment">//----------------------</span>
    <span class="comment">// Start the CBW read operation</span>
    transfer-&gt;semaphore = 0;
    status = <a class="code" href="group__usbd__interface.html#gaa786fa9bbfd3c2f64b5f486e537ffebb">USBD_Read</a>(<a class="code" href="group__usbd__msdd__config.html#ga3cdfe4df582ad8c8b85f38c5124ce2da">MSDDriverDescriptors_BULKOUT</a>,
                       cbw,
                       <a class="code" href="group__usbd__msd__cbw__def.html#ga22be7c06d4161d4789757eda169cfb5d">MSD_CBW_SIZE</a>,
                       (<a class="code" href="group__usbd__interface.html#gabb63140a294168cea538f0bad09d561a">TransferCallback</a>) MSDDriver_Callback,
                       (<span class="keywordtype">void</span> *) transfer);

    <span class="comment">// Check operation result code</span>
    <span class="keywordflow">if</span> (status == <a class="code" href="group__usbd__rc.html#ga4638d75610d787870c2593d231c05b13">USBD_STATUS_SUCCESS</a>) {

        <span class="comment">// If the command was successful, wait for transfer</span>
        msdDriver.state = MSDD_STATE_WAIT_CBW;
    }
    <span class="keywordflow">break</span>;
</pre></div><p> A callback function to invoke when the transfer is complete is provided to the USBD_Read method, to update a <a class="el" href="struct_m_s_d_transfer.html">MSDTransfer</a> structure. This structure indicates the transfer completion, the returned result code and the number of transferred and remaining bytes. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  transferred; <span class="comment">//!&lt; Number of bytes transferred</span>
<span class="comment"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  remaining;   <span class="comment">//!&lt; Number of bytes not transferred</span>
<span class="comment"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> semaphore;   <span class="comment">//!&lt; Semaphore to indicate transfer completion</span>
<span class="comment"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> status;      <span class="comment">//!&lt; Operation result code</span>
<span class="comment"></span>} <a class="code" href="struct_m_s_d_transfer.html">MSDTransfer</a>;
</pre></div><p> The callback function is trivial and thus not listed here.</p>
<p><b>MSDD_STATE_WAIT_CBW</b></p>
<p>The first step here is to monitor the <em>semaphore</em> field of the <a class="el" href="struct_m_s_d_transfer.html">MSDTransfer</a> structure (see above); this will enable detection of the transfer end. Please note that this field must be declared as volatile in C, or accesses to it might get optimized by the compiler; this can result in endless loops.</p>
<p>If the transfer is complete, then the result code must be checked to see if there was an error. If the operation is successful, the state machine can proceed to command processing. Otherwise, it returns to the <a class="el" href="group__usbd__msd__driver__possible__states.html#ga4438be188193362974b17f91d3fb7c0f">MSDD_STATE_READ_CBW</a> state. </p>
<div class="fragment"><pre class="fragment"><span class="comment">//----------------------</span>
<span class="keywordflow">case</span> <a class="code" href="group__usbd__msd__driver__possible__states.html#ga31119a29c0bb1030f5858788133a9f19" title="Driver is waiting for the transfer to finish.">MSDD_STATE_WAIT_CBW</a>:
<span class="comment">//----------------------</span>
    <span class="comment">// Check transfer semaphore</span>
    <span class="keywordflow">if</span> (transfer-&gt;semaphore &gt; 0) {

        <span class="comment">// Take semaphore and terminate transfer</span>
        transfer-&gt;semaphore--;

        <span class="comment">// Check if transfer was successful</span>
        <span class="keywordflow">if</span> (transfer-&gt;status == <a class="code" href="group__usbd__rc.html#ga4638d75610d787870c2593d231c05b13">USBD_STATUS_SUCCESS</a>) {

            <span class="comment">// Process received command</span>
            msdDriver.state = MSDD_STATE_PROCESS_CBW;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (transfer-&gt;status == <a class="code" href="group__usbd__rc.html#gaa981f9bdfce634bbbf6c0997b554bc49">USBD_STATUS_RESET</a>) {

            msdDriver.state = MSDD_STATE_READ_CBW;
        }
        <span class="keywordflow">else</span> {

            msdDriver.state = MSDD_STATE_READ_CBW;
        }
    }
    <span class="keywordflow">break</span>;
</pre></div><p><b>MSDD_STATE_PROCESS_CBW</b></p>
<p>Once the CBW has been received, its validity must be checked. A CBW is not valid if:</p>
<ul>
<li>it has not been received right after a CSW was sent or a reset occured or</li>
<li>it is not exactly 31 bytes long or</li>
<li>its signature field is not equal to 43425355h</li>
</ul>
<p>The state machine prevents the first case from happening, so only the two other cases have to be verified.</p>
<p>The number of bytes transferred during a <a class="el" href="group__usbd__interface.html#gaa786fa9bbfd3c2f64b5f486e537ffebb">USBD_Read()</a> operation is passed as an argument to the callback function, if one has been specified. As stated previously, such a function is used to fill a <a class="el" href="struct_m_s_d_transfer.html">MSDTransfer</a> structure. Therefore, it is trivial to check that the CBW is indeed 31 bytes by verifying that the number of bytes transferred is 31, and that there are no remaining bytes. The following table illustrates the three cases which may happen:</p>
<table class="doxtable">
<tr>
<td><b>Number of bytes transferred</b> </td><td><b>Number of bytes remaining</b> </td><td><b>Meaning</b> </td></tr>
<tr>
<td>transferred&lt;31 </td><td>remaining==0 </td><td>CBW is too short </td></tr>
<tr>
<td>transferred==31 </td><td>remaining&gt;0 </td><td>CBW is too long </td></tr>
<tr>
<td>transferred==31 </td><td>remaining==0 </td><td>CBW length is correct </td></tr>
</table>
<p>Checking the signature is simply done by comparing the dCBWSignature field with the expected value (43425355h).</p>
<p>If the CBW is not valid, then the device must immediately halt both Bulk endpoints, to STALL further traffic from the host. In addition, it should stay in this state until a Reset Recovery is performed by the host. This is done by setting the waitResetRecovery flag in the <a class="el" href="struct_m_s_d_driver.html">MSDDriver</a> structure. Finally, the CSW status is set to report an error, and the state machine is returned to <a class="el" href="group__usbd__msd__driver__possible__states.html#ga4438be188193362974b17f91d3fb7c0f">MSDD_STATE_READ_CBW</a>.</p>
<p>Otherwise, if the CBW is correct, then the command can be processed. Remember the CBW tag must be copied regardless of the validity of the CBW.</p>
<p>Note that these steps are only necessary for a new command (remember commands are asynchronous and are carried out in several calls, so a check can be performed to avoid useless processing. A value of zero for the internal command state indicates a new command. </p>
<div class="fragment"><pre class="fragment"><span class="comment">//-------------------------</span>
<span class="keywordflow">case</span> <a class="code" href="group__usbd__msd__driver__possible__states.html#ga67608dacdd0cfb01e1671c546d8cc44e" title="Driver is processing the received command.">MSDD_STATE_PROCESS_CBW</a>:
<span class="comment">//-------------------------</span>
    <span class="comment">// Check if this is a new command</span>
    <span class="keywordflow">if</span> (commandState-&gt;state == 0) {

        <span class="comment">// Copy the CBW tag</span>
        csw-&gt;dCSWTag = cbw-&gt;dCBWTag;

        <span class="comment">// Check that the CBW is 31 bytes long</span>
        <span class="keywordflow">if</span> ((transfer-&gt;transferred != <a class="code" href="group__usbd__msd__cbw__def.html#ga22be7c06d4161d4789757eda169cfb5d">MSD_CBW_SIZE</a>) ||
            (transfer-&gt;remaining != 0)) {

            <span class="comment">// Wait for a reset recovery</span>
            msdDriver.waitResetRecovery = 1;

            <span class="comment">// Halt the Bulk-IN and Bulk-OUT pipes</span>
            <a class="code" href="group__usbd__interface.html#ga02adabcf042f350cc045fb2c798bb4e9">USBD_Halt</a>(<a class="code" href="group__usbd__msdd__config.html#ga3cdfe4df582ad8c8b85f38c5124ce2da">MSDDriverDescriptors_BULKOUT</a>);
            <a class="code" href="group__usbd__interface.html#ga02adabcf042f350cc045fb2c798bb4e9">USBD_Halt</a>(<a class="code" href="group__usbd__msdd__config.html#ga04bc2dac2c0377bca6b5db25053c94e6">MSDDriverDescriptors_BULKIN</a>);

            csw-&gt;bCSWStatus = MSD_CSW_COMMAND_FAILED;
            msdDriver.state = MSDD_STATE_READ_CBW;

        }
        <span class="comment">// Check the CBW Signature</span>
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cbw-&gt;dCBWSignature != <a class="code" href="group__usbd__msd__cbw__def.html#ga68b7dd45dbcddc5a5c4c82ddbd18c389">MSD_CBW_SIGNATURE</a>) {

            <span class="comment">// Wait for a reset recovery</span>
            msdDriver.waitResetRecovery = 1;

            <span class="comment">// Halt the Bulk-IN and Bulk-OUT pipes</span>
            <a class="code" href="group__usbd__interface.html#ga02adabcf042f350cc045fb2c798bb4e9">USBD_Halt</a>(<a class="code" href="group__usbd__msdd__config.html#ga3cdfe4df582ad8c8b85f38c5124ce2da">MSDDriverDescriptors_BULKOUT</a>);
            <a class="code" href="group__usbd__interface.html#ga02adabcf042f350cc045fb2c798bb4e9">USBD_Halt</a>(<a class="code" href="group__usbd__msdd__config.html#ga04bc2dac2c0377bca6b5db25053c94e6">MSDDriverDescriptors_BULKIN</a>);

            csw-&gt;bCSWStatus = MSD_CSW_COMMAND_FAILED;
            msdDriver.state = MSDD_STATE_READ_CBW;
        }
        <span class="keywordflow">else</span> {

            <span class="comment">// Pre-process command</span>
            MSDDriver_PreProcessCommand();
        }
    }

    <span class="comment">// Process command</span>
    <span class="keywordflow">if</span> (csw-&gt;bCSWStatus == <a class="code" href="group__usbd__msd__driver__result__codes.html#gac61cb43d544c951f2a751350801cb95b" title="Method was successful.">MSDD_STATUS_SUCCESS</a>) {

        <span class="keywordflow">if</span> (MSDDriver_ProcessCommand()) {

            <span class="comment">// Post-process command if it is finished</span>
            MSDDriver_PostProcessCommand();
            msdDriver.state = MSDD_STATE_SEND_CSW;
        }
    }

    <span class="keywordflow">break</span>;
</pre></div><p><b>MSDD_STATE_SEND_CSW</b></p>
<p>This state is similar to <a class="el" href="group__usbd__msd__driver__possible__states.html#ga4438be188193362974b17f91d3fb7c0f">MSDD_STATE_READ_CBW</a>, except that a write operation is performed instead of a read and the CSW is sent, not the CBW. The same callback function is used to fill the transfer structure, which is checked in the next state: </p>
<div class="fragment"><pre class="fragment"><span class="comment">//----------------------</span>
<span class="keywordflow">case</span> <a class="code" href="group__usbd__msd__driver__possible__states.html#gadc35d496eed9e672951d6e99eb38b42b" title="Driver is starting the transmission of a command status wrapper.">MSDD_STATE_SEND_CSW</a>:
<span class="comment">//----------------------</span>
    <span class="comment">// Set signature</span>
    csw-&gt;dCSWSignature = MSD_CSW_SIGNATURE;

    <span class="comment">// Start the CSW write operation</span>
    status = <a class="code" href="group__usbd__interface.html#gafc4728f4af70056b3a271f333b759592">USBD_Write</a>(<a class="code" href="group__usbd__msdd__config.html#ga04bc2dac2c0377bca6b5db25053c94e6">MSDDriverDescriptors_BULKIN</a>,
                        csw,
                        <a class="code" href="group__usbd__msd__csw__def.html#ga77981cb946634e377f21685b5db11491">MSD_CSW_SIZE</a>,
                        (<a class="code" href="group__usbd__interface.html#gabb63140a294168cea538f0bad09d561a">TransferCallback</a>) MSDDriver_Callback,
                        (<span class="keywordtype">void</span> *) transfer);

    <span class="comment">// Check operation result code</span>
    <span class="keywordflow">if</span> (status == <a class="code" href="group__usbd__rc.html#ga4638d75610d787870c2593d231c05b13">USBD_STATUS_SUCCESS</a>) {

        <span class="comment">// Wait for end of transfer</span>
        msdDriver.state = MSDD_STATE_WAIT_CSW;
    }
    <span class="keywordflow">break</span>;
</pre></div><p><b>MSDD_STATE_WAIT_CSW</b></p>
<p>Again, this state is very similar to <a class="el" href="group__usbd__msd__driver__possible__states.html#ga31119a29c0bb1030f5858788133a9f19">MSDD_STATE_WAIT_CBW</a>. The only difference is that the state machine is set to <a class="el" href="group__usbd__msd__driver__possible__states.html#ga4438be188193362974b17f91d3fb7c0f">MSDD_STATE_READ_CBW</a> regardless of the operation result code: </p>
<div class="fragment"><pre class="fragment"><span class="comment">//----------------------</span>
<span class="keywordflow">case</span> <a class="code" href="group__usbd__msd__driver__possible__states.html#ga88259e0a67d0dc45a54a59ebfab9bb11" title="Driver is waiting for the CSW transmission to finish.">MSDD_STATE_WAIT_CSW</a>:
<span class="comment">//----------------------</span>
    <span class="comment">// Check transfer semaphore</span>
    <span class="keywordflow">if</span> (transfer-&gt;semaphore &gt; 0) {

        <span class="comment">// Take semaphore and terminate transfer</span>
        transfer-&gt;semaphore--;

        <span class="comment">// Read new CBW</span>
        msdDriver.state = MSDD_STATE_READ_CBW;
    }
    <span class="keywordflow">break</span>;
</pre></div><h3><a class="anchor" id="Media"></a>
Media</h3>
<p>USB MSD Media access is three-level abstraction.</p>
<div align="center">
<img src="MSDMediaArch.png" alt="MSDMediaArch.png"/>
<p><strong>Media Architecture</strong></p></div>
<p> The bottom level is the specific driver for each media type (See memories).</p>
<p>In the middle, a structure <a class="el" href="usbd_msd_drv.html#Media">Media</a> is used to hide which specific driver a media instance is using. This enables transparent use of any media driver once it has been initialized (See <a class="el" href="struct___media.html" title="Media object.">_Media</a>).</p>
<p>Finally, a LUN abstraction is made over the media structure to allow multiple partitions over one media. This also makes it possible to place the LUN at any address and use any block size. When performing a write or read operation on a LUN, it forwards the operation to the underlying media while translating it to the correct address and length.</p>
<h4><a class="anchor" id="med_drv"></a>
Media Drivers</h4>
<p>A media driver must provide several functions for:</p>
<ul>
<li>Reading data from the media</li>
<li>Writing data on the media</li>
<li>Handling interrupts on the media The last function may be empty if the media does not require interrupts for asynchronous operation, or if synchronous operation produces an acceptable delay.</li>
</ul>
<p>In addition, it should also define a function for initializing a Media structure with the correct values, as well as perform the necessary step for the media to be useable.</p>
<p>For the drivers see:</p>
<ul>
<li><a class="el" href="_m_e_d_sdram_8h_source.html">MEDSdram.h</a>: <em>Internal Flash Driver</em></li>
<li><a class="el" href="_m_e_d_flash_8h_source.html">MEDFlash.h</a>: <em>SDRAM disk driver</em></li>
</ul>
<h3><a class="anchor" id="scsi_cmd"></a>
SCSI Commands</h3>
<p>The example software described in this application note uses SCSI commands with the MSD class, since this is the most appropriate setting for a Flash device. This section details how SCSI commands are processed.</p>
<h4><a class="anchor" id="Documents"></a>
Documents</h4>
<p>There are several documents covering SCSI commands. In this application note, the reference document used is SCSI Block Commands - 3 (SBC-3). However, it makes many references to another SCSI document, SCSI Primary Commands - 4 (SPC-4). Both are needed for full details on required commands.</p>
<h4><a class="anchor" id="Endianness"></a>
Endianness</h4>
<p>SCSI commands use the big-endian format for storing word- and double word- sized data. This means the Most Significant Bit (MSB) is stored at the lowest address, and the Least Significant Bit (LSB) at the highest one.</p>
<p>On ARM Thumb microcontrollers, the endianness of the core is selectable. However, the little-endian mode is most often used. Therefore, SCSI command data must be converted before being usable. This is done by declaring word- and dword-sized fields as byte arrays, and then using a macro for loading or storing data. Several of them are available in the provided software:</p>
<ul>
<li>Load<ul>
<li>WORDB: Converts a big-endian word value to little-endian</li>
<li>DWORDB: Converts a big-endian double-word value to little-endian</li>
</ul>
</li>
<li>Store<ul>
<li>STORE_WORDB: Stores a little-endian word value in big-endian format</li>
<li>STORE_DWORDB: Stores a little-endian double-word value in big-endian format</li>
</ul>
</li>
</ul>
<h4><a class="anchor" id="sense_data"></a>
Sense Data</h4>
<p>When an error happens during the execution of a command, it is recorded by the device. The host may then issue a Request Sense command to retrieve <b>Sense Data</b>, i.e., information about previous errors.</p>
<p>While the sense data structure has many fields, only three are really important. The first one is the Sense Key. It indicates the result of the last command performed: success, media not ready, hardware error, etc. Two other fields can then be specified to give a more accurate description of the problem. They are named <em>Additional Sense Code</em> and <em>Additional Sense Code Qualifier</em>.</p>
<p>In the example application, each LUN has its own sense data. It is updated during command execution if there is any error.</p>
<h4><a class="anchor" id="Commands"></a>
Commands</h4>
<p>The SBC-3 specification gives a list of mandatory and optional commands that are relevant for a block device (like a Flash drive). In practice, only a subset of the mandatory commands is effectively used by operating systems; conversely, several commands which are supposed to be optional are required. The software provided with this application note implements the following list of commands:</p>
<ul>
<li>SBC-3<ul>
<li>Prevent/Allow Medium Removal</li>
<li>Read (10)</li>
<li>Read Capacity (10)</li>
<li>Verify (10)</li>
<li>Write (10)</li>
</ul>
</li>
<li>SPC-4<ul>
<li>Inquiry</li>
<li>Mode Sense (6)</li>
<li>Request Sense</li>
<li>Test Unit Ready The commands are actually processed in SBC_ProcessCommand.</li>
</ul>
</li>
</ul>
<p><em>Internal State Machine</em></p>
<p>As previously stated, most commands have an internal state machine to prevent blocking the whole system during a data transfer (on the USB or when accessing a media). A result code is used to indicate that the corresponding function must be called again for the command to complete (<a class="el" href="group__usbd__msd__driver__result__codes.html#gac61cb43d544c951f2a751350801cb95b">MSDD_STATUS_SUCCESS</a>).</p>
<p>A command state structure is used by the driver to record several parameters during command processing: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>{

    <a class="code" href="struct_m_s_d_transfer.html">MSDTransfer</a> transfer;       <span class="comment">//!&lt; Current transfer status</span>
<span class="comment"></span>    <a class="code" href="struct_m_s_cbw.html">MSCbw</a>      cbw;             <span class="comment">//!&lt; Received CBW</span>
<span class="comment"></span>    <a class="code" href="struct_m_s_csw.html">MSCsw</a>      csw;             <span class="comment">//!&lt; CSW to send</span>
<span class="comment"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  <a class="code" href="rtt_2main_8c.html#a186a62101b060340b694962650a14338">state</a>;       <span class="comment">//!&lt; Current command state</span>
<span class="comment"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  postprocess; <span class="comment">//!&lt; Actions to perform when command is complete</span>
<span class="comment"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   length;      <span class="comment">//!&lt; Remaining length of command</span>
<span class="comment"></span>
} <a class="code" href="struct_m_s_d_command_state.html">MSDCommandState</a>;
</pre></div><p>Note that the <em>state</em> field must be initialized when the command is first called. A value of 0 means that no command is currently being executed.</p>
<p>For the commands descriptions and implementation, please reffer to the SCSI spec. and source code.</p>
<p>Functions to handle SCSI commands:</p>
<ul>
<li>SBC_Inquiry</li>
<li>SBC_Read10</li>
<li>SBC_ReadCapacity10</li>
<li>SBC_RequestSense</li>
<li>SBC_TestUnitReady</li>
<li>SBC_Write10</li>
<li>SBC_ModeSense6</li>
</ul>
<h4><a class="anchor" id="cmd_process"></a>
Command Processing</h4>
<p><em>Flow</em></p>
<p>Command processing is actually divided into three phases in the example software:</p>
<ul>
<li>Pre-processing: MSDDriver_PreProcessCommand</li>
<li>Processing: MSDDriver_ProcessCommand</li>
<li>Post-processing: MSDDriver_PostProcessCommand</li>
</ul>
<p><em>The Thirteen Cases</em></p>
<p>There are basically three actions that should be performed depending on the case:</p>
<ul>
<li>STALL the Bulk-IN endpoint</li>
<li>STALL the Bulk-OUT endpoint</li>
<li>Report a Phase Error in the CSW</li>
</ul>
<p>The table below lists all cases along with the actions which must be taken after the command, including the correct length/direction of the transfer. The following notation is used to characterize host and device expectations:</p>
<p>Data <a class="el" href="struct_transfer.html">Transfer</a> Characterization </p>
<table class="doxtable">
<tr>
<td><b>Notation</b> </td><td><b>Meaning</b> </td><td><b>Notation</b> </td><td><b>Meaning</b> </td></tr>
<tr>
<td>Hn </td><td>Host expects no data transfer </td><td>Dn </td><td>Device expects no data transfer </td></tr>
<tr>
<td>Hi </td><td>Host expects to <b>receive</b> data </td><td>Di </td><td>Device expects to <b>send</b> data </td></tr>
<tr>
<td>Ho </td><td>Host expects to <b>send</b> data </td><td>Do </td><td>Device expects to <b>receive</b> data </td></tr>
<tr>
<td>Lh </td><td>Length of data expected by the host </td><td>Ld </td><td><p class="starttd">Length of data expected by the device</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Hx=Dx </td><td>Host and device agree on transfer length and direction (x is either n, i or o) </td><td></td><td></td></tr>
<tr>
<td>Hx&gt;Dx </td><td>Host and device agree on transfer direction, host expects a larger transfer than device </td><td></td><td></td></tr>
<tr>
<td>Hx&lt;Dx </td><td>Host and device agree on transfer direction, device expects a larger transfer than host </td><td></td><td></td></tr>
<tr>
<td>Hx&lt;&gt;Dx </td><td>Host and device disagree on transfer direction </td><td></td><td></td></tr>
</table>
<p>The Thirteen Cases </p>
<table class="doxtable">
<tr>
<td><b>#</b> </td><td><b>Case</b> </td><td><b>Length</b> </td><td><b>Residue</b> </td><td><b>Direction</b> </td><td><b>STALL IN?</b> </td><td><b>STALL OUT?</b> </td><td><b>Phase Error?</b> </td></tr>
<tr>
<td>1</td><td>Hn = Dn</td><td>0</td><td>0</td><td>Irrelevant</td><td></td><td></td><td></td></tr>
<tr>
<td>2</td><td>Hn &lt; Di</td><td>0</td><td>Ld - Lh</td><td>Irrelevant</td><td></td><td></td><td>X </td></tr>
<tr>
<td>3</td><td>Hn &lt; Do</td><td>0</td><td>Ld - Lh</td><td>Irrelevant</td><td></td><td></td><td>X </td></tr>
<tr>
<td>4</td><td>Hi &gt; Dn</td><td>0</td><td>Lh</td><td>Irrelevant</td><td>X</td><td></td><td></td></tr>
<tr>
<td>5</td><td>Hi &gt; Di</td><td>Ld</td><td>Lh - Ld</td><td>In</td><td>X</td><td></td><td></td></tr>
<tr>
<td>6</td><td>Hi = Di</td><td>Ld</td><td>0</td><td>In</td><td></td><td></td><td></td></tr>
<tr>
<td>7</td><td>Hi &lt; Di</td><td>Lh</td><td>Ld - Lh</td><td>In</td><td></td><td></td><td>X </td></tr>
<tr>
<td>8</td><td>Hi &lt;&gt; Do</td><td>0</td><td>0</td><td>Irrelevant</td><td>X</td><td></td><td>X </td></tr>
<tr>
<td>9</td><td>Ho &gt; Dn</td><td>0</td><td>Lh</td><td>Irrelevant</td><td></td><td>X</td><td></td></tr>
<tr>
<td>10</td><td>Ho &lt;&gt; Di</td><td>0</td><td>0</td><td>Irrelevant</td><td></td><td>X</td><td>X </td></tr>
<tr>
<td>11</td><td>Ho &gt; Do</td><td>Ld</td><td>Lh - Ld</td><td>Out</td><td></td><td>X</td><td></td></tr>
<tr>
<td>12</td><td>Ho = Do</td><td>Ld</td><td>0</td><td>Out</td><td></td><td></td><td></td></tr>
<tr>
<td>13</td><td>Ho &lt; Do</td><td>Lh</td><td>Lh - Ld</td><td>Out</td><td></td><td></td><td>X </td></tr>
</table>
<h3><a class="anchor" id="main_app"></a>
Main Application</h3>
<p>After the MSD driver and the media have been initialized using the corresponding functions, the only requirement for the main application is to regularly call the state machine function. This is necessary for processing received commands in a fully asynchronous way.</p>
<p>The application is otherwise free of doing any other task; for example, it could implement a filesystem and a serial port interface to be accessed with a standard terminal. An MP3 player could also continue playing a song while its memory is accessed like an external hard disk.</p>
<div align="center">
<img src="MSDDriverClasses.png" alt="MSDDriverClasses.png"/>
<p><strong>Driver Class Diagram</strong></p></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
